<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>ChessVerse - Play Online</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Rimosso settings.css per usare lo stile minimale della homepage; temi inline sotto -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #312e2b;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        .header {
            background: #262522;
            border-bottom: 1px solid #3d3d3d;
            padding: 0;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 32px;
            padding-left: 16px;
        }
        
        .logo {
            font-size: 24px;
            font-weight: 700;
            color: #8b4d8b;
            text-decoration: none;
        }
        
        .nav-links {
            display: flex;
            gap: 24px;
        }
        
        .nav-links a {
            color: #b9b9b9;
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .nav-links a:hover {
            color: #ffffff;
            background: #3d3d3d;
        }
        
        .header-right {
            padding-right: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 16px;
            display: flex;
            gap: 24px;
        }
        
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .board-container {
            position: relative;
            margin-bottom: 24px;
        }
        
        .chessboard {
            --board-size: 560px;
            width: var(--board-size);
            height: var(--board-size);
            border: 3px solid #8b4d8b;
            border-radius: 4px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            --board-light: #f0d9b5;
            --board-dark: #b58863;
            background: linear-gradient(135deg, var(--board-light) 0%, var(--board-dark) 100%);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
    /* Evidenziazione selezione & ultima mossa in stile homepage */
    .square.selected::before{content:"";position:absolute;inset:0;background:rgba(139,77,139,0.28);box-shadow:inset 0 0 0 4px #8b4d8b;pointer-events:none;}
    .square.last-move:not(.selected)::before{content:"";position:absolute;inset:0;background:rgba(247,247,105,0.35);pointer-events:none;z-index:1;}
    .square{position:relative;}
    /* Overlays (promozione / game over) stile index */
    .dialog-overlay{position:fixed;inset:0;background:rgba(0,0,0,.65);display:none;align-items:center;justify-content:center;z-index:10000}
    .dialog{background:#1f1f1f;padding:24px 28px;border:1px solid #3d3d3d;border-radius:12px;width:320px;text-align:center}
    .promotion-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:16px}
    .promo-choice{background:#2c2c2c;padding:12px 0;border-radius:8px;font-size:34px;cursor:pointer;transition:background .15s}
    .promo-choice:hover{background:#3a3a3a}

    /* === SETTINGS MODAL (stile homepage unificato) === */
    #settingsOverlay{position:fixed;inset:0;background:rgba(0,0,0,.75);display:none;z-index:10000;overflow:auto}
    #settingsOverlay .settings-modal{background:#262421;margin:60px auto;padding:24px;border-radius:12px;max-width:900px;width:90%;color:#fff;border:1px solid #3d3d3d}
    .settings-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
    .settings-tabs{display:flex;gap:8px;margin-bottom:16px;flex-wrap:nowrap;align-items:center}
    .settings-tab{padding:8px 14px;background:#3d3d3d;border-radius:6px;font-size:13px;cursor:pointer;font-weight:600;transition:.15s;flex:1;text-align:center}
    .settings-tab.active,.settings-tab:hover{background:#8b4d8b;color:#fff}
    .settings-tab{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .settings-panel{display:none;gap:16px;flex-wrap:wrap}
    .settings-panel.active{display:flex}
    .setting-item{flex:1 1 240px;background:#1f1f1f;border:1px solid #3d3d3d;padding:12px 14px;border-radius:10px;display:flex;flex-direction:column;gap:8px;min-width:220px}
    .setting-item h4{font-size:14px;margin:0;font-weight:600;color:#fff}
    .setting-item small{font-size:11px;color:#b9b9b9}
    .setting-item input[type=range]{width:100%}
    .toggle{width:44px;height:24px;border-radius:20px;background:#555;position:relative;cursor:pointer;transition:.2s}
    .toggle::after{content:"";position:absolute;width:20px;height:20px;background:#fff;border-radius:50%;top:2px;left:2px;transition:.2s}
    .toggle.active{background:#8b4d8b}
    .toggle.active::after{transform:translateX(20px)}
    select, input[type=color]{background:#2c2c2c;color:#fff;border:1px solid #555;padding:6px 8px;border-radius:6px;font-family:inherit}
    .close-btn{background:#3d3d3d;border:none;color:#fff;padding:4px 8px;border-radius:5px;cursor:pointer;font-size:12px;line-height:1.1}
    .close-btn:hover{background:#555}
    /* Settings gear button unified */
    .settings-btn{background:#3d3d3d;color:#fff;border:none;padding:8px 10px;border-radius:6px;cursor:pointer;display:flex;align-items:center}
    .settings-btn:hover{background:#4a4a4a}
    @media (max-width:620px){.settings-tabs{flex-wrap:nowrap;overflow-x:auto;-webkit-overflow-scrolling:touch}.settings-tab{flex:0 0 auto}}
    /* Temi scacchiera (estratti da settings.css) */
    .chessboard.theme-brown .square.light {background-color:#f0d9b5!important}
    .chessboard.theme-brown .square.dark {background-color:#b58863!important}
    .chessboard.theme-green .square.light {background-color:#eeeed2!important}
    .chessboard.theme-green .square.dark {background-color:#769656!important}
    .chessboard.theme-blue .square.light {background-color:#dee3e6!important}
    .chessboard.theme-blue .square.dark {background-color:#8ca2ad!important}
    .chessboard.theme-purple .square.light {background-color:#e8e9f7!important}
    .chessboard.theme-purple .square.dark {background-color:#9f90c4!important}
    .chessboard.theme-gray .square.light {background-color:#e5e5e5!important}
    .chessboard.theme-gray .square.dark {background-color:#999999!important}
        
        .square {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            overflow: hidden;
        }
        
    .square.light { background: var(--board-light); }
    .square.dark { background: var(--board-dark); }
        
    /* (Vecchi stili evidenziazione rimossi: ora gestione dinamica via script) */
        
        .piece {
            width: 85%;
            height: 85%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: grab;
            transition: transform 0.1s;
            z-index: 10;
        }
        
        .piece:hover {
            transform: scale(1.1);
        }
        
        .piece.dragging {
            cursor: grabbing;
            transform: scale(1.2);
            z-index: 1000;
            pointer-events: none;
        }
        
        /* Pezzi bianchi */
        .piece.white.king { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22.5 11.63V6'/%3e%3cpath d='M20 8h5' stroke-linecap='butt'/%3e%3cpath d='M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5' fill='%23fff' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z' fill='%23fff'/%3e%3cpath d='M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0' stroke='%23000'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.white.queen { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 8.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z'/%3e%3cpath d='M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z' stroke-linecap='butt'/%3e%3cpath d='M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z' stroke-linecap='butt'/%3e%3cpath d='M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0' fill='none'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.white.rook { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5' stroke-linecap='butt'/%3e%3cpath d='M34 14l-3 3H14l-3-3'/%3e%3cpath d='M31 17v12.5H14V17' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M31 29.5l1.5 2.5h-20l1.5-2.5'/%3e%3cpath d='M11 14h23' fill='none' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.white.bishop { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cg fill='%23fff' stroke-linecap='butt'%3e%3cpath d='M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2zM15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2zM25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z'/%3e%3c/g%3e%3cpath d='M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.white.knight { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21' fill='%23fff'/%3e%3cpath d='M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3' fill='%23fff'/%3e%3cpath d='M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zM14.933 15.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z' fill='%23000'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.white.pawn { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cpath d='M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z' fill='%23fff' stroke='%23000' stroke-width='1.5' stroke-linecap='round'/%3e%3c/svg%3e"); }
        
        /* Pezzi neri */
        .piece.black.king { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23000' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22.5 11.63V6' stroke='%23000'/%3e%3cpath d='M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5' fill='%23000' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z' fill='%23000'/%3e%3cpath d='M20 8h5' stroke='%23000' stroke-linecap='butt'/%3e%3cpath d='M32 29.5s8.5-4 6.03-9.65C34.15 14 25 18 22.5 24.5l.01 2.1-.01-2.1C20 18 9.906 14 6.997 19.85c-2.497 5.65 4.853 9 6.853 9.65' stroke='%23fff'/%3e%3cpath d='M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0' stroke='%23fff'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.black.queen { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23000' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 8.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z'/%3e%3cpath d='M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z' stroke-linecap='butt'/%3e%3cpath d='M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z' stroke-linecap='butt'/%3e%3cpath d='M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0' fill='none'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.black.rook { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23000' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M9 39h27v-3H9v3zM12.5 32l1.5-2.5h17l1.5 2.5h-20zM12 36v-4h21v4H12z' stroke-linecap='butt'/%3e%3cpath d='M14 29.5v-13h17v13H14z' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M14 16.5L11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z' stroke-linecap='butt'/%3e%3cpath d='M12 35.5h21M13 31.5h19M14 29.5h17M14 16.5h17M11 14h23' fill='none' stroke='%23fff' stroke-width='1' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.black.bishop { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cg fill='%23000' stroke-linecap='butt'%3e%3cpath d='M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2zM15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2zM25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z'/%3e%3c/g%3e%3cpath d='M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5' stroke='%23fff' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.black.knight { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21' fill='%23000'/%3e%3cpath d='M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3' fill='%23000'/%3e%3cpath d='M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zM14.933 15.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z' fill='%23fff' stroke='%23fff'/%3e%3cpath d='M24.55 10.4l-.45 1.45.5.15c3.15 1 5.65 2.49 7.9 6.75S35.75 29.06 35.25 39l-.05.5h2.25l.05-.5c.5-10.06-.88-16.85-3.25-21.34-2.37-4.49-5.79-6.64-9.19-7.16l-.51-.1z' fill='%23fff' stroke='none'/%3e%3c/g%3e%3c/svg%3e"); }
        .piece.black.pawn { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cpath d='M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z' fill='%23000' stroke='%23000' stroke-width='1.5' stroke-linecap='round'/%3e%3c/svg%3e"); }
        
        .sidebar {
            width: 280px;
            background: #262421;
            border-radius: 8px;
            padding: 20px;
            height: fit-content;
        }
        
        .sidebar h3 {
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
        }
        
        .online-notice {
            background: #262421;
            border: 2px solid #8b4d8b;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .online-notice h3 {
            color: #8b4d8b;
            margin: 0 0 12px 0;
            font-size: 18px;
        }
        
        .online-notice p {
            color: #b9b9b9;
            margin: 0;
            line-height: 1.5;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #8b4d8b;
            color: #ffffff;
        }
        
        .btn-primary:hover {
            background: #7a427a;
        }
        
        .btn-secondary {
            background: #3d3d3d;
            color: #ffffff;
        }
        
        .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        .game-status {
            text-align: center;
            padding: 12px;
            background: #1a1a1a;
            border-radius: 4px;
            color: #ffffff;
            font-weight: 500;
            margin-bottom: 20px;
        }
        
        .new-game-btn {
            background: #8b4d8b;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 12px;
        }
        
        .new-game-btn:hover {
            background: #7a427a;
        }

        /* Board Controls - Zoom */
        .board-controls {
            background: #2d2d2d;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #3d3d3d;
        }

        .board-controls h3 {
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-control label {
            display: block;
            color: #cccccc;
            font-size: 14px;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .zoom-indicator {
            display: inline-block;
            background: #8b4d8b;
            color: #ffffff;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .zoom-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1a1a1a;
            outline: none;
            margin-bottom: 15px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #8b4d8b;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .zoom-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #8b4d8b;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .zoom-presets {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .preset-btn {
            flex: 1;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #3d3d3d;
            border-radius: 6px;
            color: #ffffff;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #8b4d8b;
            border-color: #8b4d8b;
        }

        .preset-btn.active {
            background: #8b4d8b;
            border-color: #8b4d8b;
        }

        /* === SISTEMA ANNOTAZIONI === */
        
        /* Canvas per frecce */
        #annotations-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* Non intercetta eventi normali */
            z-index: 900; /* Sopra i pezzi (z-index: 10) ma sotto i pezzi trascinati (z-index: 1000) */
        }

        /* Pannello controlli annotazioni */
        .annotation-controls {
            background: #262421;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .annotation-controls h3 {
            color: #ffffff;
            font-size: 16px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .square.arrow-remove-start::after{content:"";position:absolute;inset:0;box-shadow:inset 0 0 0 4px rgba(255,0,0,.65);border-radius:2px;pointer-events:none;z-index:900;}

        .annotation-modes {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            background: #3a3a3a;
            border: 1px solid #555;
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .mode-btn:hover {
            background: #4a4a4a;
            border-color: #666;
        }

        .mode-btn.active {
            background: #8b4d8b;
            border-color: #8b4d8b;
            color: white;
        }

        .color-selection {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
        }

        .color-btn {
            width: 24px;
            height: 24px;
            border: 2px solid transparent;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: rgba(255,255,255,0.5);
        }

        .color-btn.active {
            border-color: #ffffff;
            transform: scale(1.2);
        }

        .annotation-status {
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #cccccc;
            margin-bottom: 8px;
        }

        .clear-btn {
            background: #dc3545;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .clear-btn:hover {
            background: #c82333;
        }

        .annotation-info-item {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin: 2px 0;
        }

        .annotation-info-item .label {
            color: #999;
        }

        .annotation-info-item .value {
            color: #ffffff;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .color-red { background: #e74c3c; }
        .color-green { background: #27ae60; }
        .color-blue { background: #3498db; }
        .color-yellow { background: #f1c40f; }
        .color-orange { background: #e67e22; }
        .color-purple { background: #9b59b6; }

        .annotation-info {
            font-size: 12px;
            color: #cccccc;
            text-align: center;
        }

            /* Palette styling for analysis board */
            .pal-item {
                min-width: 40px;
                min-height: 40px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                background: #1a1a1a;
                border: 1px solid #333;
                border-radius: 6px;
                color: #fff;
                cursor: pointer;
                user-select: none;
            }
            .pal-item.selected { outline: 2px solid #8b4d8b; }

        /* Evidenziazioni celle */
        .square.highlighted {
            position: relative;
        }

        .square.highlighted::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 3px solid;
            border-radius: 4px;
            pointer-events: none;
            z-index: 5;
        }

        /* Stili evidenziazione rimossi - ora usa solo .square.highlight::before per cerchi trasparenti */
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <a href="/" class="logo">ChessVerse</a>
            <nav class="nav-links">
                <a href="/play">Gioca Online</a>
                <a href="/bot">Bot Arena</a>
                <a href="/analysis" class="active">Analizza</a>
            </nav>
        </div>
        <div class="header-right">
            <a href="#" class="settings-btn" title="Impostazioni" onclick="openSettings();return false;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                </svg>
            </a>
            <button class="btn btn-primary">Accedi</button>
        </div>
    </header>

    <div class="main-container">

        <div class="game-area" style="display: flex; flex-direction: row; align-items: flex-start;">
            <div id="evalbar-container" style="margin-right: 18px; display: flex; flex-direction: column; align-items: flex-end; justify-content: flex-start; height: 100%;">
                <div id="evalbar" style="width: 28px; height: 560px; background: #999; border-radius: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.18); position: relative; overflow: hidden;">
                        <!-- Top fill: white (solid) -->
                        <div id="evalbar-top" style="position:absolute; top:0; left:0; right:0; height:50%; background:#fff; border-top-left-radius:0; border-top-right-radius:0; transition: height 0.25s linear; z-index:2;"></div>
                        <!-- Bottom fill: black (solid) -->
                        <div id="evalbar-bottom" style="position:absolute; bottom:0; left:0; right:0; height:50%; background:#000; border-bottom-left-radius:0; border-bottom-right-radius:0; transition: height 0.25s linear; z-index:1;"></div>
                        <!-- Advantage score, will be positioned on the advantaged side -->
                        <div id="evalbar-score" style="position:absolute; left: 36px; transform: translateX(0); color:#000; font-weight:700; font-size:14px; pointer-events:none; min-width:36px; text-align:center;"></div>
                    </div>
            </div>
            <div class="board-container">
                <div class="chessboard" id="chessboard"></div>
                <canvas id="annotations-canvas"></canvas>
            </div>
        </div>

        <div class="sidebar">
            <h3>Analysis</h3>
            <div class="controls">
                <button id="setupBtn" class="btn btn-secondary">Setup</button>
                <button id="selfPlayBtn" class="btn btn-secondary">Self-play: Off</button>
                <button id="clearSetupBtn" class="btn btn-secondary" style="display:none">Exit Setup</button>
            </div>

            <div style="margin-top:18px">
                <h3 style="margin-bottom:8px">Palette</h3>
                <div id="palette" style="display:flex;gap:8px;flex-wrap:wrap"></div>
                <div id="heldPieceBox" style="margin-top:8px;height:36px"></div>
            </div>

            <div style="margin-top:18px">
                <h3 style="margin-bottom:8px">FEN</h3>
                <textarea id="fenArea" style="width:100%;height:80px;background:#1a1a1a;color:#fff;border:1px solid #3d3d3d;padding:8px;border-radius:6px">rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR</textarea>
                <div style="display:flex;gap:8px;margin-top:8px">
                    <button id="loadFenBtn" class="btn btn-secondary">Load FEN</button>
                    <button id="exportFenBtn" class="btn btn-secondary">Export</button>
                    <button id="copyFenBtn" class="btn btn-secondary">Copy</button>
                </div>
            </div>

            <div style="margin-top:18px">
                <h3 style="margin-bottom:8px">Tools</h3>
                <button id="resetBoardBtn" class="btn btn-primary">Reset Board</button>
                <button id="analyzeBtn" class="btn btn-secondary">Analyze</button>
            </div>
        </div>
    </div>

    <script th:inline="none">
    // === Motore locale completo (copiato da index + adattamenti) ===
    const START_FEN='rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    const UNICODE={K:'\u2654',Q:'\u2655',R:'\u2656',B:'\u2657',N:'\u2658',P:'\u2659',k:'\u265A',q:'\u265B',r:'\u265C',b:'\u265D',n:'\u265E',p:'\u265F'};
    const state={fen:START_FEN,selected:null,lastFrom:null,lastTo:null,cache:new Map(),gameOver:false,winner:null};
    const arrows=[]; const highlights=new Set();
    const other=c=>c==='white'?'black':'white';
    const sq=(r,c)=>String.fromCharCode(97+c)+(8-r);
    const pos=s=>[8-parseInt(s[1]), s.charCodeAt(0)-97];
    const pColor=p=>p===p.toUpperCase()?'white':'black';
    function parseFen(f){const p=f.split(' ');return{board:p[0].split('/').map(r=>{const out=[];for(const c of r){if(/\d/.test(c)) for(let i=0;i<+c;i++) out.push(null); else out.push(c);}return out;}),active:p[1]==='w'?'white':'black',castling:p[2],ep:p[3]==='-'?null:p[3],half:+p[4]||0,full:+p[5]||1};}
    function boardToFen(b){return b.map(r=>{let s='',n=0;for(const c of r){if(!c) n++; else {if(n){s+=n;n=0;} s+=c;}} if(n) s+=n; return s;}).join('/');}
    function composeFen(o){return[boardToFen(o.board),o.active==='white'?'w':'b',o.castling||'-',o.ep||'-',o.half,o.full].join(' ');}    
    function generateLegalMoves(f){if(state.cache.has(f)) return state.cache.get(f);const st=parseFen(f);const color=st.active;const opp=other(color);let kSq=null;const pseudo=[];for(let r=0;r<8;r++) for(let c=0;c<8;c++){const pc=st.board[r][c];if(pc&&pc.toLowerCase()==='k'&&pColor(pc)===color) kSq=sq(r,c);}for(let r=0;r<8;r++) for(let c=0;c<8;c++){const pc=st.board[r][c];if(!pc||pColor(pc)!==color) continue;const from=sq(r,c);const l=pc.toLowerCase();if(l==='p'){const dir=color==='white'?-1:1;const start=color==='white'?6:1;const one=r+dir;if(one>=0&&one<8&&!st.board[one][c]){pseudo.push({from,to:sq(one,c),piece:pc});if(r===start&&!st.board[r+2*dir][c]) pseudo.push({from,to:sq(r+2*dir,c),piece:pc,epTarget:sq(one,c)});}for(const dc of[-1,1]){const tr=r+dir,tc=c+dc;if(tr<0||tr>7||tc<0||tc>7) continue; if(st.board[tr][tc]&&pColor(st.board[tr][tc])===opp) pseudo.push({from,to:sq(tr,tc),piece:pc});}if(st.ep){const[er,ec]=pos(st.ep);if(er===r+dir&&Math.abs(ec-c)===1) pseudo.push({from,to:sq(er,ec),piece:pc,enPassant:true});}} else if(l==='n'){const d=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];for(const[dr,dc] of d){const tr=r+dr,tc=c+dc;if(tr<0||tr>7||tc<0||tc>7) continue;const t=st.board[tr][tc];if(!t||pColor(t)===opp) pseudo.push({from,to:sq(tr,tc),piece:pc});}} else if(l==='b'||l==='r'||l==='q'){const dirs=[];if(l!=='r') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);if(l!=='b') dirs.push([1,0],[-1,0],[0,1],[0,-1]);for(const[dr,dc] of dirs){let tr=r+dr,tc=c+dc;while(tr>=0&&tr<8&&tc>=0&&tc<8){const t=st.board[tr][tc];if(!t) pseudo.push({from,to:sq(tr,tc),piece:pc}); else {if(pColor(t)===opp) pseudo.push({from,to:sq(tr,tc),piece:pc});break;}tr+=dr;tc+=dc;}}} else if(l==='k'){for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){if(!dr&&!dc) continue;const tr=r+dr,tc=c+dc;if(tr<0||tr>7||tc<0||tc>7) continue;const t=st.board[tr][tc];if(!t||pColor(t)===opp) pseudo.push({from,to:sq(tr,tc),piece:pc});} if(!isAttacked(st,kSq,color)){if(st.castling.includes(color==='white'?'K':'k')) if(!st.board[r][c+1]&&!st.board[r][c+2]&&!isAttacked(st,sq(r,c+1),color)&&!isAttacked(st,sq(r,c+2),color)) pseudo.push({from,to:sq(r,c+2),piece:pc,castle:'king'});if(st.castling.includes(color==='white'?'Q':'q')) if(!st.board[r][c-1]&&!st.board[r][c-2]&&!st.board[r][c-3]&&!isAttacked(st,sq(r,c-1),color)&&!isAttacked(st,sq(r,c-2),color)) pseudo.push({from,to:sq(r,c-2),piece:pc,castle:'queen'});} } }
        const legal=[];for(const m of pseudo){const newSt=applyPseudo(st,m);if(!kingSafe(newSt,color)) continue; if(m.piece==='P'&&m.to[1]==='8'){['Q','R','B','N'].forEach(pr=>legal.push({...m,promotion:pr}));continue;} if(m.piece==='p'&&m.to[1]==='1'){['q','r','b','n'].forEach(pr=>legal.push({...m,promotion:pr}));continue;} legal.push(m);}state.cache.set(f,legal);return legal; }
    function kingSafe(st,color){let k=null;for(let r=0;r<8;r++) for(let c=0;c<8;c++){const p=st.board[r][c];if(p&&p.toLowerCase()==='k'&&pColor(p)===color) k=sq(r,c);}return !isAttacked(st,k,color);}    
    function isAttacked(st,s,color){const opp=other(color);const[r,c]=pos(s);const dir=opp==='white'?-1:1;for(const dc of[-1,1]){const rr=r+dir,cc=c+dc;if(rr>=0&&rr<8&&cc>=0&&cc<8){const p=st.board[rr][cc];if(p&&p.toLowerCase()==='p'&&pColor(p)===opp) return true;}}const N=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];for(const[dr,dc] of N){const rr=r+dr,cc=c+dc; if(rr<0||rr>7||cc<0||cc>7) continue;const p=st.board[rr][cc];if(p&&p.toLowerCase()==='n'&&pColor(p)===opp) return true;}const rays=[[1,0,['r','q']],[-1,0,['r','q']],[0,1,['r','q']],[0,-1,['r','q']],[1,1,['b','q']],[-1,1,['b','q']],[1,-1,['b','q']],[-1,-1,['b','q']]];for(const[dr,dc,types] of rays){let rr=r+dr,cc=c+dc;while(rr>=0&&rr<8&&cc>=0&&cc<8){const p=st.board[rr][cc];if(p){if(pColor(p)===opp&&types.includes(p.toLowerCase())) return true;break;} rr+=dr;cc+=dc;}}for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){if(!dr&&!dc) continue;const rr=r+dr,cc=c+dc;if(rr<0||rr>7||cc<0||cc>7) continue;const p=st.board[rr][cc];if(p&&p.toLowerCase()==='k'&&pColor(p)===opp) return true;}return false;}
    function applyPseudo(st,m){const ns={...st,board:st.board.map(r=>r.slice())};const[fr,fc]=pos(m.from);const[tr,tc]=pos(m.to);const piece=ns.board[fr][fc];ns.board[fr][fc]=null;if(m.enPassant){const capR=piece==='P'?tr+1:tr-1;ns.board[capR][tc]=null;} if(m.castle==='king'){ns.board[tr][tc]=piece;ns.board[tr][tc-1]=ns.board[tr][7];ns.board[tr][7]=null;} else if(m.castle==='queen'){ns.board[tr][tc]=piece;ns.board[tr][tc+1]=ns.board[tr][0];ns.board[tr][0]=null;} else {ns.board[tr][tc]= m.promotion ? (pColor(piece)==='white'? m.promotion : m.promotion.toLowerCase()) : piece;} let rights=ns.castling.replace(/-/,''); if(rights){if(m.from==='a1'||m.to==='a1') rights=rights.replace('Q',''); if(m.from==='h1'||m.to==='h1') rights=rights.replace('K',''); if(m.from==='a8'||m.to==='a8') rights=rights.replace('q',''); if(m.from==='h8'||m.to==='h8') rights=rights.replace('k','');} if(piece.toLowerCase()==='k'){rights=rights.replace(pColor(piece)==='white'?'K':'k',''); rights=rights.replace(pColor(piece)==='white'?'Q':'q','');} ns.castling=rights||'-'; ns.ep=m.epTarget || (m.enPassant? null:null); ns.active=other(st.active); ns.half=piece.toLowerCase()==='p'?0:st.half+1; if(ns.active==='white') ns.full=st.full+1; return ns;}
    function pieceClass(ch){const white=ch===ch.toUpperCase();const map={k:'king',q:'queen',r:'rook',b:'bishop',n:'knight',p:'pawn'};return (white?'white ':'black ')+map[ch.toLowerCase()];}
    function clearAnnotations(){ if(arrows.length||highlights.size){arrows.length=0;highlights.clear();arrowRemoveStart=null;redrawAnnotations();updateHighlightDom();}}
    function render(){
        const el = document.getElementById('chessboard');
        el.innerHTML = '';
        const st = parseFen(state.fen);
        const highlightLast = (typeof getSetting === 'function' ? getSetting('highlightLastMove') : true);
        for (let r = 0; r < 8; r++){
            for (let c = 0; c < 8; c++){
                const square = document.createElement('div');
                square.className = 'square ' + (((r + c) % 2 === 0) ? 'light' : 'dark');
                const name = sq(r, c);
                square.dataset.square = name;
                if (highlights.has(name)) square.classList.add('highlight');
                if (highlightLast && (state.lastFrom === name || state.lastTo === name)) square.classList.add('last-move');
                const piece = st.board[r][c];
                if (piece){
                    const pc = document.createElement('div');
                    pc.className = 'piece ' + pieceClass(piece);
                    // store canonical piece code so palette / FEN helpers can read it
                    pc.dataset.piece = piece;
                    // Controllo robusto drag: permesso in setup, oppure in modalità
                    // 'gioco locale' (selfPlay=false) per i pezzi del colore attivo.
                    // Ricalcoliamo la permission ad ogni render per mantenere
                    // consistenza quando lo stato cambia.
                    try{
                        const meta = parseFen(state.fen);
                        const pieceColor = pColor(piece);
                        // Allow dragging in setup, or when selfPlay is enabled for the active color.
                        // Previously local play was allowed when selfPlay was false; change that
                        // so moves are only possible while selfPlay is true (per user's request).
                        const canDrag = inSetup || (selfPlay && pieceColor === meta.active);
                        pc.draggable = !!canDrag;
                        pc.setAttribute('draggable', pc.draggable);
                        // attach handlers always but guard with current state inside
                        pc.addEventListener('dragstart', e => {
                            // re-evaluate permission at event time
                            const nowMeta = parseFen(state.fen);
                            const nowColor = pColor(piece);
                            const nowCanDrag = inSetup || (selfPlay && nowColor === nowMeta.active);
                            if(!nowCanDrag){ e.preventDefault(); return; }
                            console.log('[analysis_board] dragstart', name, 'inSetup=', inSetup, 'selfPlay=', selfPlay);
                            state._didDrop = false; e.dataTransfer.setData('text/plain', name); state.dragFrom = name;
                        });
                        pc.addEventListener('dragend', () => {
                            try {
                                if (inSetup && state.dragFrom && !state._didDrop) {
                                    const from = state.dragFrom;
                                    const sttmp = parseFen(state.fen);
                                    const [fr, fc] = pos(from);
                                    const b = sttmp.board.map(r => r.slice());
                                    b[fr][fc] = null;
                                    state.fen = composeFen({ board: b, active: sttmp.active, castling: sttmp.castling, ep: sttmp.ep, half: sttmp.half, full: sttmp.full });
                                    render();
                                }
                            } catch (e) {}
                            state.dragFrom = null; state._didDrop = false;
                        });
                    
                    square.appendChild(pc);
                    }catch(e){
                        try{ const elScore = document.getElementById('evalbar-score'); if(elScore) elScore.textContent = 'N/A'; }catch(_){} }
                }
                square.addEventListener('click', (e) => {
                    // the mousedown/mouseup arrow/annotation handlers and should
                    // not trigger placement/deletion logic (prevents palette 'DEL' from deleting on right-click).
                    if(e.button !== 0) return;
                    // Allow clicks in setup to reach onSquare (which handles palette/held/existing logic)
                    // Always treat a left-click as a chance to clear annotations if present
                    if (arrows.length || highlights.size){ clearAnnotations(); }
                    arrowRemoveStart = null; renderArrowRemoveMarker(); onSquare(name, e);
                });

                square.addEventListener('dragover', e => e.preventDefault());
                square.addEventListener('drop', e => {
                    e.preventDefault();
                    if (inSetup){
                        const from = state.dragFrom || e.dataTransfer.getData('text/plain');
                        if (!from) return;
                        const fromR = 8 - parseInt(from[1]), fromC = from.charCodeAt(0) - 97;
                        const toR = r, toC = c;
                        const board = parseFen(state.fen).board.map(row => row.slice());
                        // Solo se il pezzo di partenza è bianco
                        if (board[fromR] && board[fromR][fromC]){
                            // Overwrite target square (allow both-color moves in setup)
                            board[toR][toC] = board[fromR][fromC];
                            board[fromR][fromC] = null;
                            state._didDrop = true;
                            const meta = parseFen(state.fen);
                            state.fen = composeFen({ board, active: meta.active, castling: meta.castling, ep: meta.ep, half: meta.half, full: meta.full });
                            render();
                        }
                    } else {
                        // Only allow drops to perform moves when selfPlay is enabled
                        if (state.dragFrom && selfPlay) tryMove(state.dragFrom, name);
                    }
                });

                square.addEventListener('mousedown', e => onMouseDownSquare(e, name));
                square.addEventListener('mouseup', e => onMouseUpSquare(e, name));
                el.appendChild(square);
            }
        }
    if(state.selected){
        // Use nullish coalescing so an explicit `false` from settings works, undefined falls back to true
        const showMoves = (typeof getSetting === 'function' ? (getSetting('showLegalMoves') ?? true) : true);
        if(showMoves){
            const moves=generateLegalMoves(state.fen).filter(m=>m.from===state.selected);
            moves.forEach(m=>{
                const t=document.querySelector(`[data-square="${m.to}"]`);
                if(t){ t.classList.add('possible-move'); if(t.querySelector('.piece')) t.classList.add('occupied'); }
            });
        }
        const sel=document.querySelector(`[data-square="${state.selected}"]`);
        if(sel) sel.classList.add('selected');
    }
    updateStatus(); applyHighlightSettings(); redrawAnnotations(); renderArrowRemoveMarker();
    // --- FEN textarea sync: always update after render ---
    const fenArea = document.getElementById('fenArea');
    if(fenArea) fenArea.value = state.fen;
    // Trigger evaluation update when render completes (debounced)
    try{ scheduleEvalUpdate(state.fen); }catch(e){}
    }
    function toggleHighlight(s){ if(highlights.has(s)) highlights.delete(s); else highlights.add(s); updateHighlightDom(); }
    function updateHighlightDom(){ document.querySelectorAll('.square.highlight').forEach(el=>{const n=el.dataset.square; if(!highlights.has(n)) el.classList.remove('highlight');}); highlights.forEach(n=>{const el=document.querySelector(`[data-square="${n}"]`); if(el) el.classList.add('highlight');}); applyHighlightSettings(); }
    function applyHighlightSettings(){
        let colorHex='#8b4d8b', op=.8;
        if(typeof getSetting==='function'){
            colorHex=getSetting('highlightColor')||colorHex;
            const raw=getSetting('highlightOpacity');
            if(raw!=null) op=raw/100;
        }
        const r=parseInt(colorHex.slice(1,3),16),g=parseInt(colorHex.slice(3,5),16),b=parseInt(colorHex.slice(5,7),16);
        let stEl=document.getElementById('highlight-dynamic-style');
        if(!stEl){
            stEl=document.createElement('style');
            stEl.id='highlight-dynamic-style';
            document.head.appendChild(stEl);
        }
        
        stEl.textContent=`
        .square.highlight::before{content:'';position:absolute;inset:0;pointer-events:none;z-index:800;
                background: radial-gradient(circle at center, transparent 0 74%, rgba(${r},${g},${b},${op}) 60% 100%);
        }
        .square.possible-move:not(.occupied)::after{content:"";position:absolute;width:64%;height:34%;background:rgba(0,0,0,0);border-radius:50%;box-shadow:0 0 0 4px rgba(0,0,0,0.0);pointer-events:none;}
    `;
    }
    // Frecce
    let arrowDragStart=null; let removeArrowDragStart=null; let arrowRemoveStart=null; function onMouseDownSquare(e,name){ if(e.button===2) arrowDragStart=name; else if(e.button===0) removeArrowDragStart=name; }
    function onMouseUpSquare(e,name){ if(e.button===2 && arrowDragStart){ const from=arrowDragStart,to=name; if(from!==to) toggleArrow(from,to); else toggleHighlight(from); arrowDragStart=null; if(state.selected){ state.selected=null; } render(); return; } if(e.button===0 && removeArrowDragStart){ removeArrowDragStart=null; }}
    function toggleArrow(from,to){ const idx=arrows.findIndex(a=>a.from===from&&a.to===to); if(idx>=0) arrows.splice(idx,1); else arrows.push({from,to}); }
    function renderArrowRemoveMarker(){ document.querySelectorAll('.square.arrow-remove-start').forEach(el=>el.classList.remove('arrow-remove-start')); if(arrowRemoveStart){ const el=document.querySelector(`[data-square="${arrowRemoveStart}"]`); if(el) el.classList.add('arrow-remove-start'); } }
    function redrawAnnotations(){ const canvas=document.getElementById('annotations-canvas'); if(!canvas) return; const board=document.getElementById('chessboard'); const rect=board.getBoundingClientRect(); canvas.width=rect.width; canvas.height=rect.height; const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); const squareSize=canvas.width/8; const scaleFactor=squareSize/70; arrows.forEach(a=>drawArrow(ctx,a.from,a.to,'main',canvas,scaleFactor)); }
    function drawArrow(ctx,from,to,colorKey,canvas,scale){
        const [fr,fc]=pos(from); const [tr,tc]=pos(to);
        const ss=canvas.width/8;
        const fromX=(fc+0.5)*ss, fromY=(fr+0.5)*ss, toX=(tc+0.5)*ss, toY=(tr+0.5)*ss;
        let arrowColor=(typeof getSetting==='function'?(getSetting('arrowColor')||'#8b4d8b'):'#8b4d8b');
        const opacity=(typeof getSetting==='function'? (getSetting('arrowOpacity')||80)/100:0.8);
        ctx.globalAlpha=opacity;
        ctx.strokeStyle=arrowColor;
        ctx.fillStyle=arrowColor;
        const baseThickness=(typeof getSetting==='function'?(getSetting('arrowThickness')||12):12);
        const thickness=baseThickness*scale;
        ctx.lineWidth=thickness;
        ctx.lineCap='round';
        // --- Knight move detection ---
        const dr=Math.abs(fr-tr), dc=Math.abs(fc-tc);
        const isKnight=(dr===2&&dc===1)||(dr===1&&dc===2);
        // --- Arrowhead size proportional to thickness ---
        const arrowLength=(24 + thickness*1.2);
        const baseWidth=arrowLength * 1.2;
        const arrowAngle=Math.PI/7;
        if(isKnight){
            let midX, midY;
            if(dr===2&&dc===1){ midX=fromX; midY=toY; } else { midX=toX; midY=fromY; }
            const dx=toX-midX, dy=toY-midY;
            const len=Math.sqrt(dx*dx+dy*dy);
            const shorten=arrowLength*0.6;
            const tipX=toX-shorten*(dx/len);
            const tipY=toY-shorten*(dy/len);
            ctx.beginPath();
            ctx.moveTo(fromX,fromY);
            ctx.lineTo(midX,midY);
            ctx.lineTo(tipX,tipY);
            ctx.stroke();
            const angleKnight=Math.atan2(toY-midY,toX-midX);
            const base1X=tipX + baseWidth/2 * Math.cos(angleKnight + Math.PI/2);
            const base1Y=tipY + baseWidth/2 * Math.sin(angleKnight + Math.PI/2);
            const base2X=tipX + baseWidth/2 * Math.cos(angleKnight - Math.PI/2);
            const base2Y=tipY + baseWidth/2 * Math.sin(angleKnight - Math.PI/2);
            const headX=tipX + arrowLength * Math.cos(angleKnight);
            const headY=tipY + arrowLength * Math.sin(angleKnight);
            ctx.beginPath();
            ctx.moveTo(headX, headY);
            ctx.lineTo(base1X, base1Y);
            ctx.lineTo(base2X, base2Y);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha=1;
            return;
        }
        // --- Normal arrow ---
        const angleNorm=Math.atan2(toY-fromY,toX-fromX);
        const shorten=arrowLength * 0.6;
        const adjX=toX-shorten*Math.cos(angleNorm);
        const adjY=toY-shorten*Math.sin(angleNorm);
        ctx.beginPath();
        ctx.moveTo(fromX,fromY);
        ctx.lineTo(adjX,adjY);
        ctx.stroke();
        const tipX=adjX;
        const tipY=adjY;
        const base1X=tipX + baseWidth/2 * Math.cos(angleNorm + Math.PI/2);
        const base1Y=tipY + baseWidth/2 * Math.sin(angleNorm + Math.PI/2);
        const base2X=tipX + baseWidth/2 * Math.cos(angleNorm - Math.PI/2);
        const base2Y=tipY + baseWidth/2 * Math.sin(angleNorm - Math.PI/2);
        const headX=tipX + arrowLength * Math.cos(angleNorm);
        const headY=tipY + arrowLength * Math.sin(angleNorm);
        ctx.beginPath();
        ctx.moveTo(headX, headY);
        ctx.lineTo(base1X, base1Y);
        ctx.lineTo(base2X, base2Y);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha=1;
    }
    document.addEventListener('contextmenu',e=>{ if(e.target.closest && e.target.closest('#chessboard')) e.preventDefault(); }); window.addEventListener('resize',()=>redrawAnnotations());
    function onSquare(sqName){
        if(state.gameOver) return;
        // If not in setup and selfPlay is disabled, only allow selection (no moves)
        if(!inSetup && !selfPlay){
            try{
                if(state.selected){
                    if(state.selected===sqName){ state.selected=null; render(); return; }
                    // Do not attempt to move when selfPlay is disabled; allow selecting opposing pieces of active color
                    const st=parseFen(state.fen);
                    const [r,c]=pos(sqName);
                    const pc=st.board[r][c];
                    if(pc && pColor(pc)===st.active){ state.selected=sqName; render(); }
                } else {
                    const st=parseFen(state.fen);
                    const [r,c]=pos(sqName);
                    const pc=st.board[r][c];
                    if(pc && pColor(pc)===st.active){ state.selected=sqName; render(); }
                }
            }catch(e){ console.error('[analysis_board] onSquare selection-only error', e); }
            return;
        }
        // Normal behavior (either in setup, or selfPlay is enabled)
        if(state.selected){
            if(state.selected===sqName){ state.selected=null; render(); return; }
            if(!tryMove(state.selected,sqName)){
                const st=parseFen(state.fen);
                const [r,c]=pos(sqName);
                const pc=st.board[r][c];
                if(pc && pColor(pc)===parseFen(state.fen).active){ state.selected=sqName; render(); }
            }
        } else {
            const st=parseFen(state.fen);
            const [r,c]=pos(sqName);
            const pc=st.board[r][c];
            if(pc && pColor(pc)===st.active){ state.selected=sqName; render(); }
        }
    }
    function tryMove(from,to){ const legal=generateLegalMoves(state.fen); const mv=legal.find(m=>m.from===from&&m.to===to); if(!mv){ flashInvalid(to); return false;} if(mv.promotion){ showPromotion(from,to,mv); return true;} applyMove(mv); return true; }
    function flashInvalid(sqName){ const el=document.querySelector(`[data-square="${sqName}"]`); if(!el) return; el.classList.add('invalid'); setTimeout(()=>el.classList.remove('invalid'),350); }
    function applyMove(m){
        // Defensive: validate move against current legal moves to prevent stale/premove/bot illegal moves
        try{
            const legal = generateLegalMoves(state.fen) || [];
            const ok = legal.some(lm=> lm.from===m.from && lm.to===m.to && ( (lm.promotion && m.promotion && lm.promotion.toUpperCase()===m.promotion.toUpperCase()) || (!lm.promotion && !m.promotion) ));
            if(!ok){ flashInvalid(m.to); console.warn('Blocked illegal/stale move', m); return false; }
        }catch(e){ console.warn('applyMove validation error', e); }

        const st=parseFen(state.fen);
        const ns=applyPseudo(st,m);
        state.lastFrom=m.from; state.lastTo=m.to; state.fen=composeFen(ns); state.selected=null; state.cache.clear();
        // play move/capture sound (if audio helpers are available)
        try{ const [tr,tc]=pos(m.to); const captured = !!st.board[tr][tc]; if(typeof playMoveSound==='function') playMoveSound(captured ? 'capture' : 'move'); }catch(e){}
    checkEnd(); render();
    // FEN textarea sync: ensure update after move
    const fenArea = document.getElementById('fenArea');
    if(fenArea) fenArea.value = state.fen;
        return true;
    }
    function checkEnd(){ const moves=generateLegalMoves(state.fen); const st=parseFen(state.fen); const color=st.active; let king=null; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=st.board[r][c]; if(p&&p.toLowerCase()==='k'&&pColor(p)===color) king=sq(r,c);} const inCheck=isAttacked(st,king,color); if(moves.length===0){ state.gameOver=true; if(inCheck){ state.winner=other(color); showGameOver(`${state.winner==='white'?'Bianco':'Nero'} vince!`,'Scacco Matto'); } else { showGameOver('Patta','Stallo'); } } }
    function updateStatus(){
        const gs = document.getElementById('game-status');
        if(state.gameOver){
            if(gs) gs.textContent = state.winner ? (state.winner==='white'?'Bianco':'Nero')+' Vince!' : 'Patta';
            return;
        }
        const active=parseFen(state.fen).active;
        let king=null;
        const st=parseFen(state.fen);
        for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=st.board[r][c]; if(p&&p.toLowerCase()==='k'&&pColor(p)===st.active) king=sq(r,c);} 
        const inCheck=isAttacked(st,king,st.active);
        if(gs) gs.textContent = 'Turno del '+(active==='white'?'Bianco':'Nero')+(inCheck?' (Scacco)':'');
    }

    function showPromotion(from,to,proto){
        const overlay=document.getElementById('promotionOverlay');
        const grid=document.getElementById('promotionChoices');
        grid.innerHTML='';
        const isWhite=parseFen(state.fen).active==='white';
        const list=isWhite?['Q','R','B','N']:['q','r','b','n'];
        list.forEach(p=>{
            const div=document.createElement('div');
            div.className='promo-choice';
            div.textContent=UNICODE[p];
            div.onclick=()=>{
                overlay.style.display='none';
                // Defensive: re-check legal moves before applying promotion
                try{
                    const legal = generateLegalMoves(state.fen) || [];
                    const found = legal.find(m=>m.from===from && m.to===to && m.promotion && (m.promotion.toUpperCase()===p.toUpperCase() || m.promotion===p));
                    if(found){ applyMove({...proto, promotion:p.toUpperCase()}); }
                    else { flashInvalid(to); }
                }catch(e){ console.warn('promotion validation failed',e); applyMove({...proto, promotion:p.toUpperCase()}); }
            };
            grid.appendChild(div);
        });
        overlay.style.display='flex';
    }
    function hidePromotion(){ document.getElementById('promotionOverlay').style.display='none'; }
    function showGameOver(title,detail){ const ov=document.getElementById('gameOverOverlay'); if(!ov) return; document.getElementById('gameOverTitle').textContent=title; document.getElementById('gameOverDetail').textContent=detail; ov.style.display='flex'; }
    function hideGameOver(){ const ov=document.getElementById('gameOverOverlay'); if(ov) ov.style.display='none'; }
    function resetGame(){ state.fen=START_FEN; state.selected=null; state.lastFrom=null; state.lastTo=null; state.cache.clear(); state.gameOver=false; state.winner=null; hidePromotion(); hideGameOver(); render(); }
    // --- Audio helpers (WebAudio) ---
    function safeGetSetting(key, defVal){ try{ if(typeof getSetting==='function') return getSetting(key); }catch(e){} try{ const raw=localStorage.getItem('chessverse_settings'); if(raw){ const s=JSON.parse(raw); if(s && Object.prototype.hasOwnProperty.call(s,key)) return s[key]; } }catch(e){} return defVal; }
    let _audioCtx=null, _masterGain=null, _audioInited=false;
    function initAudio(){ if(_audioInited) return; try{ _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); _masterGain = _audioCtx.createGain(); const vol = (safeGetSetting('masterVolume',70)||70)/100; _masterGain.gain.value = Math.min(1, Math.max(0, vol)); _masterGain.connect(_audioCtx.destination); _audioInited=true; }catch(e){ _audioInited=false; }}
    function playTone(freq, duration=0.06, type='sine', gain=0.08){ if(!_audioInited) initAudio(); if(!_audioInited) return; try{ const o=_audioCtx.createOscillator(); const g=_audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value = gain * ((safeGetSetting('masterVolume',70)||70)/100); o.connect(g); g.connect(_masterGain); o.start(); o.stop(_audioCtx.currentTime + duration); setTimeout(()=>{ try{ o.disconnect(); g.disconnect(); }catch(e){} }, (duration+0.05)*1000); }catch(e){} }
    function playMoveSound(kind){
        try{
            if(!safeGetSetting('soundsEnabled', true)) return;
            if(kind==='capture'){
                if(!safeGetSetting('captureSounds', true)) return;
                playTone(220,0.14,'sawtooth',0.18);
                playTone(440,0.06,'sine',0.08);
            } else {
                if(!safeGetSetting('moveSounds', true)) return;
                playTone(420,0.06,'square',0.10);
                playTone(840,0.03,'sine',0.06);
            }
        }catch(e){}
    }

    // --- Analysis page additions: setup, palette, FEN controls ---
    let inSetup = false;
    let selfPlay = false;
    function setSetupMode(on){
        inSetup = !!on;
        if(inSetup){
            selfPlay = false;
        }
        const setupBtn = document.getElementById('setupBtn');
        const selfBtn = document.getElementById('selfPlayBtn');
        const clearBtn = document.getElementById('clearSetupBtn');
        if(setupBtn) setupBtn.textContent = inSetup ? 'Setup: On' : 'Setup';
        if(selfBtn) selfBtn.textContent = 'Self-play: ' + (selfPlay ? 'On' : 'Off');
        if(clearBtn) clearBtn.style.display = inSetup ? 'inline-block' : 'none';
        try{ render(); }catch(e){}
    }
    function setSelfPlayMode(on){
        selfPlay = !!on;
        if(selfPlay){
            inSetup = false;
        }
        const setupBtn = document.getElementById('setupBtn');
        const selfBtn = document.getElementById('selfPlayBtn');
        const clearBtn = document.getElementById('clearSetupBtn');
        if(setupBtn) setupBtn.textContent = inSetup ? 'Setup: On' : 'Setup';
        if(selfBtn) selfBtn.textContent = 'Self-play: ' + (selfPlay ? 'On' : 'Off');
        if(clearBtn) clearBtn.style.display = inSetup ? 'inline-block' : 'none';
        try{ render(); }catch(e){}
    }
    const pieceOrder = ['K','Q','R','B','N','P','k','q','r','b','n','p'];
    let palette=null, boardEl=null, currentFen='';
    // Note: do not attempt to preserve/call an earlier `onSquare` declaration here.
    // Function declarations are hoisted and can make preservation unreliable and
    // cause recursive calls. We'll provide a self-contained click handler below.
    let original_onSquare = null;

    function mkPieceDiv(code){
        const d=document.createElement('div');
        d.className='piece';
        if(!code) return d;
        const isUpper = (code === code.toUpperCase());
        const color = isUpper ? 'white' : 'black';
        const sym = code.toUpperCase();
        const typeMap = { 'K':'king','Q':'queen','R':'rook','B':'bishop','N':'knight','P':'pawn' };
        const type = typeMap[sym] || 'pawn';
        d.classList.add(color);
        d.classList.add(type);
        d.dataset.piece = code;
        return d;
    }

    function buildPalette(){
        if(!palette){
            console.warn('[analysis_board] palette element not found');
            // try once after a short delay (some rendering order issues)
            setTimeout(()=>{ palette=document.getElementById('palette'); if(!palette){ console.error('[analysis_board] palette still not found'); return; } buildPalette(); }, 60);
            return;
        }
        palette.innerHTML='';
        const none = document.createElement('div'); none.className='pal-item'; none.textContent='DEL'; none.dataset.code=''; none.style.padding='6px'; none.style.border='1px solid #444'; none.style.borderRadius='6px'; none.style.cursor='pointer';
        none.addEventListener('click', ()=>{ palette.querySelectorAll('.pal-item').forEach(p=>p.classList.remove('selected')); none.classList.add('selected'); }); palette.appendChild(none);
        for(const code of pieceOrder){
            const it=document.createElement('div'); it.className='pal-item'; it.dataset.code=code; it.style.padding='6px';
            it.style.border='1px solid #444'; it.style.borderRadius='6px'; it.style.cursor='pointer'; it.style.display='flex';
            it.style.alignItems='center'; it.style.justifyContent='center'; const p=mkPieceDiv(code); p.style.width='28px'; p.style.height='28px'; p.style.pointerEvents='none'; it.appendChild(p);
            it.addEventListener('click', ()=>{ palette.querySelectorAll('.pal-item').forEach(p=>p.classList.remove('selected')); it.classList.add('selected'); });
            palette.appendChild(it);
        }
        console.log('[analysis_board] palette built, items:', palette.children.length);
    }

    function updateFenFromBoard(){
        const b=[];
        for(let r=0;r<8;r++){ const row=[]; for(let c=0;c<8;c++){ const idx=r*8+c; const s=boardEl.children[idx]; const p=s.querySelector('.piece'); row.push(p? p.dataset.piece : null);} b.push(row);} currentFen = boardToFen(b);
        try{
            const meta = parseFen(state.fen);
            state.fen = composeFen({ board: b, active: meta.active, castling: meta.castling, ep: meta.ep, half: meta.half, full: meta.full });
        }catch(e){ state.fen = currentFen + ' w - - 0 1'; }
        const fa=document.getElementById('fenArea'); if(fa) fa.value=currentFen;
    }

    // --- Eval bar integration (live Stockfish via /api/eval) ---
    // Elements: #evalbar-top / #evalbar-bottom (heights) and #evalbar-score (text)
    let _evalDebounceTimer = null;
    let _lastEvalFen = null;
    let _lastEngineUnavailableAt = 0;
    const ENGINE_COOLDOWN_MS = 5000; // if engine unavailable, wait this long before retrying
    function scheduleEvalUpdate(fen){
        // If fen didn't change, skip
        if(!fen) return;
        if(fen === _lastEvalFen) return;
        _lastEvalFen = fen;
        if(_evalDebounceTimer) clearTimeout(_evalDebounceTimer);
        // debounce ~700ms after last render/move
        _evalDebounceTimer = setTimeout(()=>{ requestEval(fen); _evalDebounceTimer = null; }, 700);
    }

    function parseEvalString(evalStr){
        // Returns object: { type: 'cp'|'mate'|'na', value: number }
        if(!evalStr) return { type: 'na', value: 0 };
        evalStr = String(evalStr).trim();
        if(evalStr.startsWith('#')){
            // mate: like #3 or #-3
            const v = parseInt(evalStr.slice(1), 10);
            if(Number.isNaN(v)) return { type: 'na', value: 0 };
            return { type: 'mate', value: v };
        }
        // centipawn-ish: might be "+1.23" or "+123" (assume pawn units if contains '.')
        let num = parseFloat(evalStr.replace('+',''));
        if(Number.isNaN(num)) return { type: 'na', value: 0 };
        // If the string seems like centipawns (large int), normalize to pawns
        if(Math.abs(num) > 20) num = num / 100.0; // convert cp to pawns
        return { type: 'cp', value: num };
    }

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function evalToPercent(evalObj){
        // Map evaluation (in pawn units) to [0,100] percent for the fill height.
        // We clamp at +/-10 pawns as extremes. Use a smooth sigmoid-like mapping.
        if(!evalObj || evalObj.type === 'na') return 50;
        if(evalObj.type === 'mate'){
            // If mate in favor, push extreme to full white; if negative mate, full black
            return evalObj.value > 0 ? 98 : 2;
        }
        const pawns = evalObj.value;
        const max = 10.0; // 10 pawns = 100%
        // Use tanh for smoothness
        const t = Math.tanh(pawns / max);
        // t in (-1,1). Convert to percent where 50 is center
        return Math.round((t + 1) * 50);
    }

    async function requestEval(fen){
        try{
            // Backoff if engine recently unavailable
            if(Date.now() - _lastEngineUnavailableAt < ENGINE_COOLDOWN_MS){
                const elScore = document.getElementById('evalbar-score');
                if(elScore) elScore.textContent = 'Stockfish N/A';
                return;
            }
            const elTop = document.getElementById('evalbar-top');
            const elBottom = document.getElementById('evalbar-bottom');
            const elScore = document.getElementById('evalbar-score');
            if(!elTop || !elBottom || !elScore) return;
            elScore.textContent = '…';
            // call backend
            const resp = await fetch('/api/eval', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fen }) });
            if(!resp.ok){ elScore.textContent = 'N/A'; return; }
            const data = await resp.json();
            const evalStr = data && data.eval ? data.eval : null;
            if(!evalStr){
                // mark engine unavailable and show clear message
                _lastEngineUnavailableAt = Date.now();
                elTop.style.height = '50%'; elBottom.style.height = '50%';
                elScore.textContent = 'Stockfish N/A';
                elScore.style.color = '#000';
                elScore.style.top = '50%';
                return;
            }
            const parsed = parseEvalString(evalStr);
            const pct = evalToPercent(parsed); // 0..100, 50=balanced, higher => white advantage

            // Set solid fill heights (square corners, no gradients)
            elTop.style.height = pct + '%';
            elBottom.style.height = (100 - pct) + '%';

            // Position and color the score on the advantaged side
            let text = 'N/A';
            if(parsed.type === 'na') text = 'N/A';
            else if(parsed.type === 'mate') text = '#' + parsed.value;
            else text = (parsed.value > 0 ? '+' : '') + parsed.value.toFixed(2);

            elScore.textContent = text;

            // Vertical placement: center of the advantaged fill
            let topPercent;
            if(pct >= 50){
                // White advantage: center of top fill
                topPercent = pct / 2.0;
                elScore.style.color = '#000'; // dark text on white
            } else {
                // Black advantage: center of bottom fill
                topPercent = 100 - (100 - pct) / 2.0;
                elScore.style.color = '#fff'; // light text on black
            }
            elScore.style.top = topPercent + '%';
            elScore.style.left = '34px';
            elScore.style.transform = 'translateY(-50%)';

        }catch(e){
            try{ const elScore = document.getElementById('evalbar-score'); if(elScore) elScore.textContent = 'N/A'; }catch(_){} }
    }


    // Click handler used by the render squares
    let heldPiece=null;
    function onSquare(name, ev){
        // Only respond to left-clicks for placement/pickup logic
        if(ev && ev.button !== 0) return;
        // If not in setup, fallback to existing behavior
    console.log('[analysis_board] onSquare click', name, 'inSetup=', inSetup, 'selfPlay=', selfPlay, 'ev=', !!ev);
        if(!inSetup){
            // Use the page-local selection / try-move behavior directly. We purposely
            // avoid calling any preserved global `onSquare` because hoisting and
            // multiple declarations can lead to recursion (stack overflow).
            try{
                if(state.gameOver) return;
                if(state.selected){
                    if(state.selected===name){ state.selected=null; render(); return; }
                    if(!tryMove(state.selected,name)){
                        const st=parseFen(state.fen);
                        const [r,c]=pos(name);
                        const pc=st.board[r][c];
                        if(pc && pColor(pc)===st.active){ state.selected=name; render(); }
                    }
                } else {
                    const st=parseFen(state.fen);
                    const [r,c]=pos(name);
                    const pc=st.board[r][c];
                    if(pc && pColor(pc)===st.active){ state.selected=name; render(); }
                }
            }catch(e){ console.error('[analysis_board] fallback onSquare error', e); }
            return;
        }
        // setup mode: find square element
        const sqEl = document.querySelector(`[data-square="${name}"]`);
        if(!sqEl) return;
        // Ensure palette is found even if variable wasn't set yet
        const pal = palette || document.getElementById('palette');
        const sel = pal ? pal.querySelector('.pal-item.selected') : null;
        const existing = sqEl.querySelector('.piece');

        // Always clear annotations on left-click
        if(arrows.length || highlights.size){ clearAnnotations(); }

        // If we're holding a piece (picked up earlier), place it here
        if(heldPiece){
            sqEl.innerHTML='';
            if(heldPiece!=='') sqEl.appendChild(mkPieceDiv(heldPiece));
            heldPiece=null;
            const hb=document.getElementById('heldPieceBox'); if(hb) hb.innerHTML='';
            updateFenFromBoard();
            return;
        }

        // If a palette item is selected, place that piece (overwrite if present)
        if(sel){
            const code = sel.dataset.code;
            sqEl.innerHTML='';
            if(code!=='') sqEl.appendChild(mkPieceDiv(code));
            updateFenFromBoard();
            return;
        }

        // If clicking an existing piece, pick it up
        if(existing){
            heldPiece = existing.dataset.piece || null;
            sqEl.innerHTML='';
            const hb=document.getElementById('heldPieceBox');
            if(hb){ hb.innerHTML=''; if(heldPiece) hb.appendChild(mkPieceDiv(heldPiece)); }
            updateFenFromBoard();
            return;
        }
    }

    // expose to global so existing square click logic uses this function
    window.onSquare = onSquare;

    // Override render so every call refreshes references (boardEl, palette)
    const _origRender = render;
    // Replace the global `render` function with a wrapper that calls the
    // original implementation and then ensures our helper refs are set.
    render = function(){ _origRender(); boardEl = document.getElementById('chessboard'); palette = document.getElementById('palette'); buildPalette(); };

    // Replace initial DOMContentLoaded behavior
    document.addEventListener('DOMContentLoaded',()=>{ initAudio(); render(); });
    window.addEventListener('storage',()=>{ render(); });

    // Setup and Self-play toggles (mutually exclusive)
    document.addEventListener('DOMContentLoaded', ()=>{
        const setupBtn=document.getElementById('setupBtn');
        const selfBtn=document.getElementById('selfPlayBtn');
        const clearBtn=document.getElementById('clearSetupBtn');
        const resetBtn=document.getElementById('resetBoardBtn');
        const analyzeBtn=document.getElementById('analyzeBtn');
        const loadFenBtn=document.getElementById('loadFenBtn');
        const exportFenBtn=document.getElementById('exportFenBtn');
        const copyFenBtn=document.getElementById('copyFenBtn');

        if(setupBtn) setupBtn.addEventListener('click', ()=>{
            // Toggle setup; ensure selfPlay disabled when entering setup
            setSetupMode(!inSetup);
            if(!inSetup){ heldPiece=null; const hb=document.getElementById('heldPieceBox'); if(hb) hb.innerHTML=''; }
            console.log('[analysis_board] setup toggled ->', inSetup);
        });

        if(selfBtn) selfBtn.addEventListener('click', ()=>{
            // Toggle self-play; ensure setup disabled when entering self-play
            setSelfPlayMode(!selfPlay);
            if(inSetup){ heldPiece=null; const hb=document.getElementById('heldPieceBox'); if(hb) hb.innerHTML=''; }
            console.log('[analysis_board] selfPlay toggled ->', selfPlay);
        });

        if(resetBtn) resetBtn.addEventListener('click', ()=>{ resetGame(); updateFenFromBoard(); });
        if(analyzeBtn) analyzeBtn.addEventListener('click', ()=>{ const fa=document.getElementById('fenArea'); const f = fa? fa.value.trim() : ''; analyzeFen(f||currentFen); });

    if(loadFenBtn) loadFenBtn.addEventListener('click', ()=>{ const fa=document.getElementById('fenArea'); if(!fa) return; try{ const parsed=parseFen(fa.value.trim()); state.fen = fa.value.trim(); render(); }catch(e){ alert('FEN non valido'); }});
        if(exportFenBtn) exportFenBtn.addEventListener('click', ()=>{ const fa=document.getElementById('fenArea'); if(fa) fa.value = currentFen; });
        if(copyFenBtn) copyFenBtn.addEventListener('click', async ()=>{ const fa=document.getElementById('fenArea'); if(!fa) return; try{ await navigator.clipboard.writeText(fa.value); alert('FEN copiata'); }catch(e){ alert('Impossibile copiare'); } });
        // Ensure palette exists and is populated; fallback observer if not present yet
        setTimeout(()=>{
            try{
                palette = document.getElementById('palette');
                if(palette){
                    if(!palette.children.length){ buildPalette(); console.log('[analysis_board] buildPalette ensured after DOM load'); }
                } else {
                    console.warn('[analysis_board] palette missing at DOMContentLoaded, attaching observer');
                    const mo = new MutationObserver((mutations, obs)=>{
                        const p = document.getElementById('palette');
                        if(p){ palette = p; buildPalette(); console.log('[analysis_board] palette found by MutationObserver'); obs.disconnect(); }
                    });
                    mo.observe(document.body, { childList: true, subtree: true });
                }
            }catch(e){ console.error('[analysis_board] palette ensure error', e); }
        }, 50);
    });
        // mark engine loaded to prevent duplicate declarations across templates
        window.__chessverse_engine_loaded = true;
    </script>
    <!-- Overlays aggiunti -->
    <div id="promotionOverlay" class="dialog-overlay">
        <div class="dialog">
            <h3>Promozione</h3>
            <p>Scegli il pezzo</p>
            <div class="promotion-grid" id="promotionChoices"></div>
        </div>
    </div>
    <div id="gameOverOverlay" class="dialog-overlay">
        <div class="dialog">
            <h2 id="gameOverTitle">Fine partita</h2>
            <p id="gameOverDetail"></p>
            <div style="margin-top:18px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
                <button onclick="resetGame();hideGameOver()">Nuova Partita</button>
                <button style="background:#444" onclick="hideGameOver()">Chiudi</button>
            </div>
        </div>
    </div>
    <!-- Settings overlay unificato (copiato da index) -->
    <div id="settingsOverlay">
        <div class="settings-modal">
            <div class="settings-header">
                <h2 style="font-size:18px;font-weight:700;color:#fff;margin:0">Impostazioni</h2>
                <button class="close-btn" onclick="closeSettings()">Chiudi</button>
            </div>
            <div class="settings-tabs">
                <div class="settings-tab active" data-tab="general">Play</div>
                <div class="settings-tab" data-tab="display">Display</div>
                <div class="settings-tab" data-tab="audio">Suoni</div>
            </div>
            <div id="general-panel" class="settings-panel active">
                <div class="setting-item">
                    <h4>Mosse Legali</h4><small>Mostra suggerimenti</small>
                    <div id="showLegalMoves" class="toggle active"></div>
                </div>
                <div class="setting-item">
                    <h4>Premosse</h4><small>Abilita premoves</small>
                    <div id="enablePremoves" class="toggle"></div>
                </div>
                <div class="setting-item">
                    <h4>Ultima Mossa</h4><small>Evidenzia</small>
                    <div id="highlightLastMove" class="toggle active"></div>
                </div>
                <div class="setting-item">
                    <h4>Animazione</h4><small>Velocità</small>
                    <select id="moveAnimation"><option value="none">None</option><option value="fast">Veloce</option><option value="normal" selected>Normale</option><option value="slow">Lenta</option></select>
                </div>
            </div>
            <div id="display-panel" class="settings-panel">
                <div class="setting-item">
                    <h4>Tema Scacchiera</h4><small>Colori</small>
                    <select id="boardTheme"><option value="brown" selected>Marrone</option><option value="green">Verde</option><option value="blue">Blu</option><option value="purple">Viola</option><option value="gray">Grigio</option></select>
                </div>
                <div class="setting-item">
                    <h4>Stile Pezzi</h4><small>Seleziona stile</small>
                    <select id="pieceStyle">
                        <option value="classic">Classico (attuale)</option>
                        <option value="pixel">Pixel</option>
                        <option value="outline">Outline</option>
                        <option value="large">Large</option>
                    </select>
                </div>
                <div class="setting-item">
                    <h4>Background</h4><small>Colore</small>
                    <input type="color" id="backgroundColor" value="#312e2b" />
                    <small style="margin-top:8px">Oppure carica un'immagine</small>
                    <input type="file" id="backgroundImage" accept="image/*" />
                </div>
                <div class="setting-item">
                    <h4>Colore Evidenzia</h4><small>Ring</small>
                    <input type="color" id="highlightColor" value="#ffff00" />
                </div>
                <div class="setting-item">
                    <h4>Opacità Evidenzia</h4><small><span id="highlightOpacityValue">85%</span></small>
                    <input type="range" id="highlightOpacity" min="30" max="100" value="85" oninput="document.getElementById('highlightOpacityValue').textContent=this.value+'%'" />
                </div>
                <!-- Frecce -->
                <div class="setting-item">
                    <h4>Colore Frecce</h4><small>Principale</small>
                    <input type="color" id="arrowColor" value="#8b4d8b" />
                </div>
                <div class="setting-item">
                    <h4>Opacità Frecce</h4><small><span id="arrowOpacityValue">80%</span></small>
                    <input type="range" id="arrowOpacity" min="20" max="100" value="80" oninput="document.getElementById('arrowOpacityValue').textContent=this.value+'%'" />
                </div>
                <div class="setting-item">
                    <h4>Spessore Frecce</h4><small><span id="arrowThicknessValue">12px</span></small>
                    <input type="range" id="arrowThickness" min="4" max="32" value="12" oninput="document.getElementById('arrowThicknessValue').textContent=this.value+'px'" />
                </div>
            </div>
            <div id="audio-panel" class="settings-panel">
                <div class="setting-item">
                    <h4>Suoni</h4><small>Abilita</small>
                    <div id="soundsEnabled" class="toggle active"></div>
                </div>
                <div class="setting-item">
                    <h4>Volume</h4><small><span id="masterVolumeValue">70%</span></small>
                    <input type="range" id="masterVolume" min="0" max="100" value="70" oninput="document.getElementById('masterVolumeValue').textContent=this.value+'%'" />
                </div>
                <div class="setting-item">
                    <h4>Mosse</h4><small>Suono mossa</small>
                    <div id="moveSounds" class="toggle active"></div>
                </div>
                <div class="setting-item">
                    <h4>Catture</h4><small>Suono cattura</small>
                    <div id="captureSounds" class="toggle active"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="/js/settings.js"></script>
    <script>
    // Gestione toggle Mosse Legali & Premosse nel modal impostazioni
    document.addEventListener('DOMContentLoaded', ()=>{
    // IDs in the DOM are 'showLegalMoves' and 'enablePremoves' (no "Toggle" suffix)
    const legalToggle = document.getElementById('showLegalMoves');
    const premoveToggle = document.getElementById('enablePremoves');

        function sync(){
            if(typeof getSetting !== 'function') return;
            const lm = !!getSetting('showLegalMoves');
            const pr = !!getSetting('enablePremoves');
            if(legalToggle) legalToggle.classList.toggle('active', lm);
            if(premoveToggle) premoveToggle.classList.toggle('active', pr);
        }

        if(legalToggle){
            legalToggle.addEventListener('click', ()=>{
                if(typeof setSetting==='function'){
                    const newVal = !getSetting('showLegalMoves');
                    setSetting('showLegalMoves', newVal);
                    if(!newVal){
                        document.querySelectorAll('.square.possible-move').forEach(e=>e.classList.remove('possible-move','occupied'));
                    } else {
                        // Se un pezzo è selezionato, rigenera markers usando lo stato locale
                        try{
                            if(typeof generateLegalMoves==='function' && state && state.selected){
                                const moves = generateLegalMoves(state.fen).filter(m=>m.from===state.selected);
                                moves.forEach(m=>{ const t=document.querySelector(`[data-square="${m.to}"]`); if(t){ t.classList.add('possible-move'); if(t.querySelector('.piece')) t.classList.add('occupied'); }});
                            }
                        }catch(e){/* non critico */}
                    }
                    sync();
                }
            });
        }
        if(premoveToggle){
            premoveToggle.addEventListener('click', ()=>{
                if(typeof setSetting==='function'){
                    const newVal = !getSetting('enablePremoves');
                    setSetting('enablePremoves', newVal);
                    if(!newVal){
                        document.querySelectorAll('.square.premove-origin').forEach(e=>e.classList.remove('premove-origin'));
                        document.querySelectorAll('.square.premove-target').forEach(e=>e.classList.remove('premove-target'));
                    }
                    sync();
                }
            });
        }
        // Delay per assicurare che settings.js abbia caricato le preferenze
        setTimeout(sync, 80);
    });
    </script>
</body>
</html>
