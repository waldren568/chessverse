<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<title>ChessVerse - Bot Arena</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<!-- Rimosso vecchio settings.css per evitare stili legacy che alterano il modal -->
<style>
*{margin:0;padding:0;box-sizing:border-box;font-family:'Noto Sans',-apple-system,BlinkMacSystemFont,sans-serif}
body{background:#312e2b;color:#fff;-webkit-font-smoothing:antialiased}
a{text-decoration:none;color:inherit}
.header{background:#262522;border-bottom:1px solid #3d3d3d;height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 16px;position:sticky;top:0;z-index:50}
.logo{font-size:24px;font-weight:700;color:#8b4d8b}
.nav-links{display:flex;gap:24px}
.nav-links a{padding:8px 12px;font-size:14px;font-weight:500;color:#b9b9b9;border-radius:4px;transition:.15s}
.nav-links a:hover,.nav-links a.active{background:#3d3d3d;color:#fff}
.header-right{display:flex;gap:8px}
.btn{padding:10px 14px;border:none;border-radius:6px;font-weight:600;cursor:pointer;transition:.15s;font-size:14px;font-family:inherit}
.btn-primary{background:#8b4d8b;color:#fff}.btn-primary:hover{background:#7a427a}
.btn-secondary{background:#3d3d3d;color:#fff}.btn-secondary:hover{background:#4a4a4a}
.settings-btn{background:#3d3d3d;color:#fff;border:none;padding:8px 10px;border-radius:6px;cursor:pointer;display:flex;align-items:center}
.settings-btn:hover{background:#4a4a4a}
.main{max-width:1250px;margin:0 auto;padding:24px 16px;display:flex;gap:28px;align-items:flex-start}
.board-wrapper{display:flex;flex-direction:column;gap:14px}
.board-container{position:relative}
.chessboard{--board-size:560px;width:var(--board-size);height:var(--board-size);display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);border:3px solid #8b4d8b;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,.35);background:linear-gradient(135deg,var(--board-light,#f0d9b5) 0%,var(--board-dark,#b58863) 100%);overflow:hidden;position:relative}
.square{position:relative;display:flex;align-items:center;justify-content:center;user-select:none;cursor:pointer;font-size:0}
.square.light{background:var(--board-light,#f0d9b5)}.square.dark{background:var(--board-dark,#b58863)}
.piece{width:85%;height:85%;background-size:contain;background-repeat:no-repeat;background-position:center;z-index:10;cursor:grab;transition:transform .12s}
.piece:active{cursor:grabbing}
/* projected ghost piece shown on hover when a piece is selected */
.projected-piece{width:85%;height:85%;background-size:contain;background-repeat:no-repeat;background-position:center;opacity:1;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(.98);pointer-events:none;z-index:25}
/* When a premove is queued, hide the original piece at its origin so only the projected ghost is visible */
.square.premove-origin .piece{visibility:hidden}
/* Pezzi bianchi */
.piece.white.king { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22.5 11.63V6'/%3e%3cpath d='M20 8h5' stroke-linecap='butt'/%3e%3cpath d='M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5' fill='%23fff' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z' fill='%23fff'/%3e%3cpath d='M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0' stroke='%23000'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.white.queen { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 8.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z'/%3e%3cpath d='M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z' stroke-linecap='butt'/%3e%3cpath d='M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z' stroke-linecap='butt'/%3e%3cpath d='M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0' fill='none'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.white.rook { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23fff' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5' stroke-linecap='butt'/%3e%3cpath d='M34 14l-3 3H14l-3-3'/%3e%3cpath d='M31 17v12.5H14V17' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M31 29.5l1.5 2.5h-20l1.5-2.5'/%3e%3cpath d='M11 14h23' fill='none' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.white.bishop { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cg fill='%23fff' stroke-linecap='butt'%3e%3cpath d='M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2zM15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2zM25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z'/%3e%3c/g%3e%3cpath d='M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.white.knight { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21' fill='%23fff'/%3e%3cpath d='M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3' fill='%23fff'/%3e%3cpath d='M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zM14.933 15.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z' fill='%23000'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.white.pawn { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cpath d='M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z' fill='%23fff' stroke='%23000' stroke-width='1.5' stroke-linecap='round'/%3e%3c/svg%3e"); }
/* Pezzi neri */
.piece.black.king { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23000' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22.5 11.63V6' stroke='%23000'/%3e%3cpath d='M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5' fill='%23000' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z' fill='%23000'/%3e%3cpath d='M20 8h5' stroke='%23000' stroke-linecap='butt'/%3e%3cpath d='M32 29.5s8.5-4 6.03-9.65C34.15 14 25 18 22.5 24.5l.01 2.1-.01-2.1C20 18 9.906 14 6.997 19.85c-2.497 5.65 4.853 9 6.853 9.65' stroke='%23fff'/%3e%3cpath d='M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0' stroke='%23fff'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.black.queen { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23000' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 8.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z'/%3e%3cpath d='M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z' stroke-linecap='butt'/%3e%3cpath d='M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z' stroke-linecap='butt'/%3e%3cpath d='M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0' fill='none' stroke='%23fff'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.black.rook { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='%23000' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M9 39h27v-3H9v3zM12.5 32l1.5-2.5h17l1.5 2.5h-20zM12 36v-4h21v4H12z' stroke-linecap='butt'/%3e%3cpath d='M14 29.5v-13h17v13H14z' stroke-linecap='butt' stroke-linejoin='miter'/%3e%3cpath d='M14 16.5L11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z' stroke-linecap='butt'/%3e%3cpath d='M12 35.5h21M13 31.5h19M14 29.5h17M14 16.5h17M11 14h23' fill='none' stroke='%23fff' stroke-width='1' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.black.bishop { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cg fill='%23000' stroke-linecap='butt'%3e%3cpath d='M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2zM15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2zM25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z'/%3e%3c/g%3e%3cpath d='M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5' stroke='%23fff' stroke-linejoin='miter'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.black.knight { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cg fill='none' fill-rule='evenodd' stroke='%23000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21' fill='%23000'/%3e%3cpath d='M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3' fill='%23000'/%3e%3cpath d='M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zM14.933 15.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z' fill='%23fff' stroke='%23fff'/%3e%3cpath d='M24.55 10.4l-.45 1.45.5.15c3.15 1 5.65 2.49 7.9 6.75S35.75 29.06 35.25 39l-.05.5h2.25l.05-.5c.5-10.06-.88-16.85-3.25-21.34-2.37-4.49-5.79-6.64-9.19-7.16l-.51-.1z' fill='%23fff' stroke='none'/%3e%3c/g%3e%3c/svg%3e"); }
.piece.black.pawn { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45 45'%3e%3cpath d='M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z' fill='%23000' stroke='%23000' stroke-width='1.5' stroke-linecap='round'/%3e%3c/svg%3e"); }
.square.selected::before{content:"";position:absolute;inset:0;background:rgba(139,77,139,.25);box-shadow:inset 0 0 0 4px #8b4d8b;border-radius:4px;pointer-events:none;z-index:200}
.square.last-move:not(.selected)::before{content:"";position:absolute;inset:0;background:rgba(247,247,105,.35);pointer-events:none;z-index:5}
.square.last-move.highlight::before{display:none}
.square.possible-move:not(.occupied)::after{content:"";position:absolute;width:34%;height:34%;background:rgba(0,0,0,0.55);border-radius:50%;box-shadow:0 0 0 4px rgba(255,255,255,0.35);pointer-events:none;}
.square.possible-move.occupied::after{content:"";position:absolute;inset:0;box-shadow:inset 0 0 0 6px rgba(255,255,255,0.28),inset 0 0 0 12px rgba(139,77,139,0.35);background:rgba(255,255,255,0.10);border-radius:4px;pointer-events:none;}
.square.premove-origin::after{/* removed decorative circle for premove origin */}
.square.premove-target::after{/* removed decorative dot for premove target */}
.square.invalid{animation:shake .35s}
@keyframes shake{10%,90%{transform:translateX(-2px)}20%,80%{transform:translateX(4px)}30%,50%,70%{transform:translateX(-6px)}40%,60%{transform:translateX(6px)}}
#annotations-canvas{position:absolute;inset:0;pointer-events:none;z-index:900}
.square.arrow-remove-start::after{content:"";position:absolute;inset:0;box-shadow:inset 0 0 0 4px rgba(255,0,0,.65);border-radius:2px;pointer-events:none;z-index:900}
.game-status{background:#1a1a1a;border:1px solid #3d3d3d;border-radius:8px;padding:12px 16px;font-weight:500;font-size:14px;text-align:center;min-height:48px;display:flex;align-items:center;justify-content:center}
.side-panel{width:320px;display:flex;flex-direction:column;gap:22px}
.panel{background:#262421;border:1px solid #3d3d3d;border-radius:12px;padding:18px;display:flex;flex-direction:column;gap:14px}
.panel h3{margin:0;font-size:15px;font-weight:600;color:#fff;display:flex;align-items:center;gap:6px}
.bot-grid{display:flex;flex-wrap:wrap;gap:12px}
.bot-card{flex:1 1 130px;min-width:125px;background:#1f1d1b;border:2px solid #3d3d3d;border-radius:10px;padding:14px;display:flex;flex-direction:column;align-items:center;gap:6px;cursor:pointer;transition:.18s}
.bot-card:hover{border-color:#8b4d8b;transform:translateY(-3px)}.bot-card.selected{border-color:#8b4d8b;box-shadow:0 0 0 2px rgba(139,77,139,.4)}
.bot-icon{font-size:30px}
.level-selector{display:none;flex-direction:column;gap:10px;background:#1e1d1b;border:1px solid #3d3d3d;border-radius:10px;padding:14px}
.level-selector.visible{display:flex}
.level-indicator{background:#8b4d8b;color:#fff;font-size:12px;padding:2px 8px;border-radius:14px;font-weight:600}
.timer{display:none;grid-template-columns:1fr 1fr;gap:8px}
.timer.active{display:grid}
.clock{background:#1a1a1a;border:1px solid #3d3d3d;border-radius:10px;padding:12px 10px;display:flex;flex-direction:column;gap:4px;align-items:center;font-variant-numeric:tabular-nums}
.clock.active{border-color:#8b4d8b;box-shadow:0 0 0 1px #8b4d8b}
.clock .name{font-size:12px;opacity:.75;font-weight:600}
.clock .time{font-size:20px;font-weight:700}
.clock.low .time{color:#ffce54}.clock.flag .time{color:#ff5252}
.controls-row{display:flex;gap:10px;flex-wrap:wrap}
.promotion-grid{display:grid;grid-template-columns:repeat(4,60px);gap:10px;margin-top:12px}
.promo-choice{width:60px;height:60px;background:#1a1a1a;border:2px solid #3d3d3d;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:38px;cursor:pointer;transition:.18s}
.promo-choice:hover{border-color:#8b4d8b;background:#262626;transform:translateY(-3px)}
.dialog-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);display:none;align-items:center;justify-content:center;z-index:6000}
.dialog{background:#262421;border:1px solid #3d3d3d;border-radius:14px;padding:24px 26px;min-width:320px;max-width:420px}
.dialog h3,.dialog h2{margin:0 0 6px;font-weight:700;color:#fff;font-size:18px}
.dialog p{margin:0 0 10px;font-size:13px;color:#cfcfcf}
.dialog button{background:#8b4d8b;color:#fff;border:none;border-radius:8px;padding:10px 14px;font-weight:600;cursor:pointer}
.dialog button:hover{background:#7a427a}
.dialog button.secondary{background:#3d3d3d}.dialog button.secondary:hover{background:#4a4a4a}
/* highlight dynamic style injected */
/* === SETTINGS OVERLAY (stile index) === */
#settingsOverlay{position:fixed;inset:0;background:rgba(0,0,0,.75);display:none;z-index:3000;overflow:auto;align-items:flex-start;justify-content:center;padding-top:60px;padding-bottom:60px}
#settingsOverlay .settings-modal{background:#262421;margin:0 auto;padding:24px;border-radius:12px;max-width:900px;width:90%;color:#fff;border:1px solid #3d3d3d}
.settings-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
.settings-tabs{display:flex;gap:8px;margin-bottom:16px;flex-wrap:nowrap;align-items:center}
.settings-tab{padding:8px 14px;background:#3d3d3d;border-radius:6px;font-size:13px;cursor:pointer;font-weight:600;transition:.15s;flex:1;text-align:center}
.settings-tab.active,.settings-tab:hover{background:#8b4d8b;color:#fff}
.settings-tab{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.settings-panel{display:none;gap:16px;flex-wrap:wrap}
.settings-panel.active{display:flex}
.setting-item{flex:1 1 240px;background:#1f1f1f;border:1px solid #3d3d3d;padding:12px 14px;border-radius:10px;display:flex;flex-direction:column;gap:8px;min-width:220px}
.setting-item h4{font-size:14px;margin:0;font-weight:600;color:#fff}
.setting-item small{font-size:11px;color:#b9b9b9}
.setting-item input[type=range]{width:100%}
.toggle{width:44px;height:24px;border-radius:20px;background:#555;position:relative;cursor:pointer;transition:.2s}
.toggle::after{content:"";position:absolute;width:20px;height:20px;background:#fff;border-radius:50%;top:2px;left:2px;transition:.2s}
.toggle.active{background:#8b4d8b}
.toggle.active::after{transform:translateX(20px)}
/* Ensure toggles in settings modal receive pointer events and sit above overlays */
#settingsOverlay .toggle{position:relative;z-index:3101;pointer-events:auto}
select,input[type=color]{background:#2c2c2c;color:#fff;border:1px solid #555;padding:6px 8px;border-radius:6px;font-family:inherit}
.close-btn{background:#3d3d3d;border:none;color:#fff;padding:4px 8px;border-radius:5px;cursor:pointer;font-size:12px;line-height:1.1}
.close-btn:hover{background:#555}
/* Evidenzia layer frecce attivo */
.arrow-layer-active{background:#8b4d8b!important;color:#fff!important}
@media (max-width:620px){.settings-tabs{flex-wrap:nowrap;overflow-x:auto;-webkit-overflow-scrolling:touch}.settings-tab{flex:0 0 auto}}
</style>
</head>
<body>
<header class="header">
    <div class="header-left" style="display:flex;align-items:center;gap:32px;">
        <a href="/" class="logo">ChessVerse</a>
        <nav class="nav-links">
            <a href="/play">Gioca Online</a>
            <a href="/bot" class="active">Bot Arena</a>
            <a href="/analysis">Analizza</a>
        </nav>
    </div>
    <div class="header-right">
    <button class="settings-btn" onclick="openSettings()" title="Impostazioni">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96a7.14 7.14 0 0 0-1.62-.94l-.36-2.54a.48.48 0 0 0-.48-.41h-3.84a.48.48 0 0 0-.47.41l-.36 2.54c-.59.24-1.13.56-1.62.94l-2.39-.96a.5.5 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58A7.3 7.3 0 0 0 4.8 12c0 .31.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32a.5.5 0 0 0-.12-.61l-2.03-1.58ZM12 15.6A3.6 3.6 0 0 1 8.4 12 3.6 3.6 0 0 1 12 8.4 3.6 3.6 0 0 1 15.6 12 3.6 3.6 0 0 1 12 15.6Z"/></svg>
    </button>
    <button class="btn btn-primary">Accedi</button>
    </div>
</header>

<main class="main">
    <div class="board-wrapper">
        <div class="board-container">
            <div class="chessboard" id="chessboard"></div>
            <canvas id="annotations-canvas"></canvas>
        </div>
        <div class="game-status" id="game-status">Seleziona un bot per iniziare</div>
        <div class="controls-row">
            <center>
                <button class="btn btn-secondary" onclick="resetGame()">üîÑ Nuova Partita</button>
            </center>
        </div>
    </div>
    <aside class="side-panel">
        <div class="panel" id="botSelectPanel">
            <h3>ü§ñ Seleziona Bot</h3>
            <div class="bot-grid">
                <div class="bot-card" data-bot="random" onclick="selectBot(this,'random')">
                    <div class="bot-icon">üé≤</div>
                    <div style="font-weight:600;font-size:14px">Random</div>
                    <div style="font-size:11px;opacity:.6">ELO ~400</div>
                </div>
                <div class="bot-card" data-bot="stockfish" onclick="selectBot(this,'stockfish')">
                    <div class="bot-icon">üêü</div>
                    <div style="font-weight:600;font-size:14px">Stockfish</div>
                    <div style="font-size:11px;opacity:.6">Livelli</div>
                </div>
            </div>
            <div class="level-selector" id="stockfish-level-box">
                <label style="font-size:12px;font-weight:600">Livello: <span id="stockfishLevelVal" class="level-indicator">5</span></label>
                <input type="range" min="1" max="20" value="5" id="stockfishLevel" oninput="updateStockfishLevel(this.value)" />
                <div style="display:flex;justify-content:space-between;font-size:11px;opacity:.65"><span>1</span><span>10</span><span>20</span></div>
            </div>
            <button class="btn btn-primary" id="startBtn" disabled onclick="startGame()">Avvia</button>
        </div>
        <div class="panel">
            <h3>‚è±Ô∏è Tempo</h3>
            <select id="timeControl" onchange="changeTimeControl(this.value)">
                <option value="unlimited" selected>Illimitato</option>
                <option value="1">1</option>
                <option value="1+2">1+2</option>
                <option value="3">3</option>
                <option value="5+3">5+3</option>
                <option value="5+3">5+3</option>
                <option value="10">10</option>
                <option value="10+5">10+5</option>
                <option value="15+10">15+10</option>
                <option value="30">30</option>
                <option value="30+30">30+30</option>
                <option value="60">60</option>
                <option value="60+30">60+30</option>
                <option value="90">90</option>
                <option value="90+30">90+30</option>
            </select>
            <div class="timer" id="timerBox">
                <div class="clock" id="whiteClock"><div class="name" id="whiteName">Tu</div><div class="time" id="whiteTime">--:--</div></div>
                <div class="clock" id="blackClock"><div class="name" id="blackName">Bot</div><div class="time" id="blackTime">--:--</div></div>
            </div>
        </div>
        <div class="panel" id="moveHistoryPanel">
            <h3>üìú Mosse</h3>
            <div id="moveHistory" style="font-size:12px;line-height:1.5;max-height:220px;overflow:auto;font-family:monospace"></div>
        </div>
    </aside>
</main>

<!-- Overlays -->
<div id="promotionOverlay" class="dialog-overlay">
    <div class="dialog">
        <h3>Promozione</h3>
        <p>Scegli il pezzo</p>
        <div class="promotion-grid" id="promotionChoices"></div>
        <div style="text-align:center;margin-top:8px"><button class="secondary" onclick="hidePromotion()">Annulla</button></div>
    </div>
</div>
<div id="gameOverOverlay" class="dialog-overlay">
    <div class="dialog">
        <h2 id="gameOverTitle">Fine partita</h2>
        <p id="gameOverDetail"></p>
        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;justify-content:center">
            <button onclick="resetGame();hideGameOver()">Nuova</button>
            <button class="secondary" onclick="hideGameOver()">Chiudi</button>
        </div>
    </div>
</div>

<!-- Settings overlay copiato da index.html -->
<div id="settingsOverlay">
    <div class="settings-modal">
        <div class="settings-header">
            <h2 style="font-size:18px;font-weight:700;color:#fff;margin:0">Impostazioni</h2>
            <button class="close-btn" onclick="closeSettings()">Chiudi</button>
        </div>
        <div class="settings-tabs">
            <div class="settings-tab active" data-tab="general">Play</div>
            <div class="settings-tab" data-tab="display">Display</div>
            <div class="settings-tab" data-tab="audio">Suoni</div>
        </div>
        <div id="general-panel" class="settings-panel active">
            <div class="setting-item">
                <h4>Mosse Legali</h4><small>Mostra suggerimenti</small>
                <div id="showLegalMoves" class="toggle active"></div>
            </div>
            <div class="setting-item">
                <h4>Premoves</h4><small>Abilita premosse</small>
                <div id="enablePremoves" class="toggle"></div>
            </div>
            <div class="setting-item">
                <h4>Ultima Mossa</h4><small>Evidenzia</small>
                <div id="highlightLastMove" class="toggle active"></div>
            </div>
            <div class="setting-item">
                <h4>Animazione</h4><small>Velocit√†</small>
                <select id="moveAnimation"><option value="none">None</option><option value="fast">Veloce</option><option value="normal" selected>Normale</option><option value="slow">Lenta</option></select>
            </div>
        </div>
        <div id="display-panel" class="settings-panel">
            <div class="setting-item">
                <h4>Tema Scacchiera</h4><small>Colori</small>
                <select id="boardTheme"><option value="brown" selected>Marrone</option><option value="green">Verde</option><option value="blue">Blu</option><option value="purple">Viola</option><option value="gray">Grigio</option></select>
            </div>
            <div class="setting-item">
                <h4>Stile Pezzi</h4><small>Seleziona stile</small>
                <select id="pieceStyle">
                    <option value="classic">Classico (attuale)</option>
                    <option value="pixel">Pixel</option>
                    <option value="outline">Outline</option>
                    <option value="large">Large</option>
                </select>
            </div>
            <div class="setting-item">
                <h4>Background</h4><small>Colore</small>
                <input type="color" id="backgroundColor" value="#312e2b" />
                <small style="margin-top:8px">Oppure carica un'immagine</small>
                <input type="file" id="backgroundImage" accept="image/*" />
            </div>
            <div class="setting-item">
                <h4>Colore Evidenzia</h4><small>Ring</small>
                <input type="color" id="highlightColor" value="#ffff00" />
            </div>
            <div class="setting-item">
                <h4>Opacit√† Evidenzia</h4><small><span id="highlightOpacityValue">85%</span></small>
                <input type="range" id="highlightOpacity" min="30" max="100" value="85" oninput="document.getElementById('highlightOpacityValue').textContent=this.value+'%'" />
            </div>
            <!-- Frecce -->
            <div class="setting-item">
                <h4>Colore Frecce</h4><small>Principale</small>
                <input type="color" id="arrowColor" value="#8b4d8b" />
            </div>
            <div class="setting-item">
                <h4>Opacit√† Frecce</h4><small><span id="arrowOpacityValue">80%</span></small>
                <input type="range" id="arrowOpacity" min="20" max="100" value="80" oninput="document.getElementById('arrowOpacityValue').textContent=this.value+'%'" />
            </div>
            <div class="setting-item">
                <h4>Spessore Frecce</h4><small><span id="arrowThicknessValue">12px</span></small>
                <input type="range" id="arrowThickness" min="4" max="32" value="12" oninput="document.getElementById('arrowThicknessValue').textContent=this.value+'px'" />
            </div>
        </div>
        <div id="audio-panel" class="settings-panel">
            <div class="setting-item">
                <h4>Suoni</h4><small>Abilita</small>
                <div id="soundsEnabled" class="toggle active"></div>
            </div>
            <div class="setting-item">
                <h4>Volume</h4><small><span id="masterVolumeValue">70%</span></small>
                <input type="range" id="masterVolume" min="0" max="100" value="70" oninput="document.getElementById('masterVolumeValue').textContent=this.value+'%'" />
            </div>
            <div class="setting-item">
                <h4>Mosse</h4><small>Suono mossa</small>
                <div id="moveSounds" class="toggle active"></div>
            </div>
            <div class="setting-item">
                <h4>Catture</h4><small>Suono cattura</small>
                <div id="captureSounds" class="toggle active"></div>
            </div>
        </div>
    </div>
</div>

<script src="/js/settings.js"></script>
<script th:inline="none">
/* === MOTORE & LOGICA BOT (versione unificata semplificata) === */
// Simple WebAudio move/capture sounds (small, dependency-free)
let _cv_audio_ctx = null;
function initAudio(){
    try{ if(!_cv_audio_ctx) _cv_audio_ctx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ _cv_audio_ctx = null; }
}
function playTone(freq, type='sine', duration=0.12, volume=0.12){
    if(!_cv_audio_ctx) try{ initAudio(); }catch(e){}
    if(!_cv_audio_ctx) return;
    const ctx = _cv_audio_ctx;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = volume;
    o.connect(g); g.connect(ctx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration);
    setTimeout(()=>{ try{o.stop(); o.disconnect(); g.disconnect();}catch(e){} }, (duration+0.02)*1000);
}
function playMoveSound(kind){
    // Respect user setting (if central API exists prefer it)
    const enabled = (typeof getSetting==='function') ? getSetting('moveSounds') : safeGetSetting ? safeGetSetting('moveSounds', true) : true;
    const master = (typeof getSetting==='function') ? getSetting('masterVolume') : safeGetSetting ? safeGetSetting('masterVolume',70) : 70;
    if(!enabled) return;
    let vol = Math.max(6, Math.min(100, master))/100;
    // Increase loudness at least 2x as requested, cap at 1.0
    vol = Math.min(1, vol * 2);
    initAudio();
    if(kind==='capture'){
        playTone(220, 'sawtooth', 0.16, 0.12*vol);
        setTimeout(()=>playTone(320,'sine',0.12,0.10*vol), 60);
    } else {
        playTone(420,'sine',0.10,0.10*vol);
    }
}
const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
const state = {
    fen: START_FEN,
    selected: null,
    lastFrom: null,
    lastTo: null,
    cache: new Map(),
    gameOver: false,
    winner: null,
    botType: null,
    botLevel: 5,
    started: false
};
// Annotazioni con doppio layer (Layout aggiuntivo richiesto: Layer 1 pieno, Layer 2 curvo tratteggiato)
const arrowLayers = { A: [], B: [] }; // A = Layer 1, B = Layer 2
let currentArrowLayer = 'A'; // layer switching UI removed
const highlights = new Set();
// premove highlights tracking (reference-counted) so multiple premoves keep their highlights
const premoveRefCount = new Map();

function computePremovePath(from,to){
    const [fr,fc]=pos(from); const [tr,tc]=pos(to);
    const dr = tr-fr, dc = tc-fc;
    const step = x=> x>0?1:(x<0?-1:0);
    const stepR = step(dr), stepC = step(dc);
    const out = [from];
    if(stepR===0 && stepC===0) return out;
    if(stepR===0 || stepC===0 || Math.abs(dr)===Math.abs(dc)){
        let r=fr+stepR, c=fc+stepC;
        while(r>=0 && r<8 && c>=0 && c<8){ out.push(sq(r,c)); if(r===tr && c===tc) break; r+=stepR; c+=stepC; }
        return out;
    }
    // fallback path
    out.push(to);
    return out;
}

function addPremoveHighlights(prem){
    const from = prem.from; const to = prem.to;
    const add = s=>{ const cur = premoveRefCount.get(s)||0; premoveRefCount.set(s, cur+1); highlights.add(s); };
    add(from); if(to!==from) add(to);
    // update DOM classes for origin/target so we can hide the original piece at origin
    const fromEl = document.querySelector(`[data-square="${from}"]`);
    if(fromEl) fromEl.classList.add('premove-origin');
    if(to!==from){ const toEl = document.querySelector(`[data-square="${to}"]`); if(toEl) toEl.classList.add('premove-target'); }
    updateHighlightDom();
    try{ console.debug('[premove] addHighlights', {id: prem._id, from: prem.from, to: prem.to, refCounts: Array.from(premoveRefCount.entries())}); }catch(e){}
}

function removePremoveHighlights(prem){
    const from = prem.from; const to = prem.to;
    const dec = s=>{ const cur = premoveRefCount.get(s)||0; if(cur<=1){ premoveRefCount.delete(s); highlights.delete(s); } else { premoveRefCount.set(s, cur-1); } };
    dec(from); if(to!==from) dec(to);
    // update DOM classes: remove premove classes only if there are no more refs for that square
    const cleanup = s=>{ if(!premoveRefCount.has(s)){ const el=document.querySelector(`[data-square="${s}"]`); if(el){ el.classList.remove('premove-origin'); el.classList.remove('premove-target'); } } };
    cleanup(from); if(to!==from) cleanup(to);
    updateHighlightDom();
    // also remove the persistent premove ghost (if any)
    try{ removePremoveProjection(prem); }catch(e){/* ignore */}
    // ensure DOM is in sync: remove any premove-origin/target classes that no longer have refs
    try{ syncPremoveDom(); }catch(e){}
    try{ console.debug('[premove] removeHighlights', {id: prem._id, from: prem.from, to: prem.to, refCounts: Array.from(premoveRefCount.entries())}); }catch(e){}
}
let arrowDragStart = null; // right mouse drag start
let removeArrowDragStart = null; // left mouse drag start
let arrowRemoveStart = null; // optional marker
// Premoves
let premoves = [];
// No projection: premoves are stored but we do not project virtual positions
// let virtualFen = null;
let isBotThinking = false;
// Projection (ghost) when a piece is selected and user hovers a legal destination
let projection = null; // {from,to,piece,...}
// Clear only hover/ephemeral projections (those without data-premove-id)
function clearProjectionDOM(){ document.querySelectorAll('.projected-piece:not([data-premove-id])').forEach(n=>n.remove()); }

function renderProjectionForMove(m){
    // ephemeral hover projection (kept for compatibility) - will not remove premove ghosts
    if(!m) return;
    clearProjectionDOM();
    const el = document.querySelector(`[data-square="${m.to}"]`);
    if(!el) return;
    const gp = document.createElement('div'); gp.className = 'projected-piece piece ' + pieceClass(m.piece);
    el.appendChild(gp);
}
function setProjection(m){ projection = m; renderProjectionForMove(m); }
function clearProjection(){ projection = null; clearProjectionDOM(); }

// Persistent premove projection management (one ghost per premove, identified by prem._id)
function addPremoveProjection(prem){
    if(!prem || !prem._id) return;
    const el = document.querySelector(`[data-square="${prem.to}"]`);
    if(!el) return;
    // create ghost only if not present
    if(el.querySelector(`.projected-piece[data-premove-id="${prem._id}"]`)) return;
    const gp = document.createElement('div'); gp.className = 'projected-piece piece ' + pieceClass(prem.piece);
    gp.dataset.premoveId = prem._id;
    el.appendChild(gp);
    try{ console.debug('[premove] addProjection', {id: prem._id, to: prem.to}); }catch(e){}
}
function removePremoveProjection(prem){
    if(!prem || !prem._id) return;
    const node = document.querySelector(`.projected-piece[data-premove-id="${prem._id}"]`);
    if(node) node.remove();
    try{ console.debug('[premove] removeProjection', {id: prem._id}); }catch(e){}
}
function activeArrows(){ return arrowLayers[currentArrowLayer]; }
function totalArrows(){ return arrowLayers.A.length + arrowLayers.B.length; }
// Utilities impostazioni (safe fallback se settings.js non ancora caricato)
const getPref = (k, defVal) => (typeof getSetting === 'function' ? getSetting(k) : defVal);

// Safe getters/setters to use if settings.js isn't loaded or hasn't initialized yet
function safeGetSetting(key, defVal){
    try{ if(typeof getSetting === 'function') return getSetting(key); }catch(e){}
    try{ const raw = localStorage.getItem('chessverse_settings'); if(raw){ const s = JSON.parse(raw); if(s && Object.prototype.hasOwnProperty.call(s,key)) return s[key]; } }catch(e){}
    return defVal;
}
function safeSetSetting(key, value){
    try{ if(typeof setSetting === 'function'){ setSetting(key, value); return; } }catch(e){}
    // Fallback: persist to localStorage and call applySettings if present
    try{
        const raw = localStorage.getItem('chessverse_settings'); let s = {};
        if(raw) s = JSON.parse(raw)||{};
        s[key] = value;
        localStorage.setItem('chessverse_settings', JSON.stringify(s));
        if(typeof applySettings === 'function') applySettings();
    }catch(e){ console.warn('[settings] safeSetSetting failed', e); }
}
const other = c => c==='white'?'black':'white';
const sq = (r,c)=> String.fromCharCode(97+c)+(8-r);
const pos = s => [8-parseInt(s[1]), s.charCodeAt(0)-97];
const pColor = p => p===p.toUpperCase()?'white':'black';

function parseFen(f){const p=f.split(' ');return{board:p[0].split('/').map(r=>{const out=[];for(const c of r){if(/\d/.test(c)) for(let i=0;i<+c;i++) out.push(null); else out.push(c);}return out;}),active:p[1]==='w'?'white':'black',castling:p[2],ep:p[3]==='-'?null:p[3],half:+p[4]||0,full:+p[5]||1};}
function boardToFen(b){return b.map(r=>{let s='',n=0;for(const c of r){if(!c) n++; else {if(n){s+=n;n=0;} s+=c;}} if(n) s+=n; return s;}).join('/');}
function composeFen(o){return[boardToFen(o.board),o.active==='white'?'w':'b',o.castling||'-',o.ep||'-',o.half,o.full].join(' ');}    

function isAttacked(st,s,color){const opp=other(color);const[r,c]=pos(s);const dir=opp==='white'?-1:1;for(const dc of[-1,1]){const rr=r+dir,cc=c+dc;if(rr>=0&&rr<8&&cc>=0&&cc<8){const p=st.board[rr][cc];if(p&&p.toLowerCase()==='p'&&pColor(p)===opp) return true;}}const N=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];for(const[dr,dc] of N){const rr=r+dr,cc=c+dc; if(rr<0||rr>7||cc<0||cc>7) continue;const p=st.board[rr][cc];if(p&&p.toLowerCase()==='n'&&pColor(p)===opp) return true;}const rays=[[1,0,['r','q']],[-1,0,['r','q']],[0,1,['r','q']],[0,-1,['r','q']],[1,1,['b','q']],[-1,1,['b','q']],[1,-1,['b','q']],[-1,-1,['b','q']]];for(const[dr,dc,types] of rays){let rr=r+dr,cc=c+dc;while(rr>=0&&rr<8&&cc>=0&&cc<8){const p=st.board[rr][cc];if(p){if(pColor(p)===opp&&types.includes(p.toLowerCase())) return true;break;} rr+=dr;cc+=dc;}}for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){if(!dr&&!dc) continue;const rr=r+dr,cc=c+dc;if(rr<0||rr>7||cc<0||cc>7) continue;const p=st.board[rr][cc];if(p&&p.toLowerCase()==='k'&&pColor(p)===opp) return true;}return false;}

function applyPseudo(st,m){const ns={...st,board:st.board.map(r=>r.slice())};const[fr,fc]=pos(m.from);const[tr,tc]=pos(m.to);const piece=ns.board[fr][fc];ns.board[fr][fc]=null;if(m.enPassant){const capR=piece==='P'?tr+1:tr-1;ns.board[capR][tc]=null;} if(m.castle==='king'){ns.board[tr][tc]=piece;ns.board[tr][tc-1]=ns.board[tr][7];ns.board[tr][7]=null;} else if(m.castle==='queen'){ns.board[tr][tc]=piece;ns.board[tr][tc+1]=ns.board[tr][0];ns.board[tr][0]=null;} else {ns.board[tr][tc]= m.promotion ? (pColor(piece)==='white'? m.promotion : m.promotion.toLowerCase()) : piece;} let rights=ns.castling.replace(/-/,''); if(rights){if(m.from==='a1'||m.to==='a1') rights=rights.replace('Q',''); if(m.from==='h1'||m.to==='h1') rights=rights.replace('K',''); if(m.from==='a8'||m.to==='a8') rights=rights.replace('q',''); if(m.from==='h8'||m.to==='h8') rights=rights.replace('k','');} if(piece.toLowerCase()==='k'){rights=rights.replace(pColor(piece)==='white'?'K':'k',''); rights=rights.replace(pColor(piece)==='white'?'Q':'q','');} ns.castling=rights||'-'; ns.ep=m.epTarget || (m.enPassant? null:null); ns.active=other(st.active); ns.half=piece.toLowerCase()==='p'?0:st.half+1; if(ns.active==='white') ns.full=st.full+1; return ns;}

function kingSafe(st,color){let k=null;for(let r=0;r<8;r++) for(let c=0;c<8;c++){const p=st.board[r][c]; if(p&&p.toLowerCase()==='k'&&pColor(p)===color) k=sq(r,c);}return !isAttacked(st,k,color);} 
function generateLegalMoves(f){ if(state.cache.has(f)) return state.cache.get(f); const st=parseFen(f); const color=st.active; const opp=other(color); let kSq=null; const pseudo=[]; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const pc=st.board[r][c]; if(pc&&pc.toLowerCase()==='k'&&pColor(pc)===color) kSq=sq(r,c);} for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const pc=st.board[r][c]; if(!pc||pColor(pc)!==color) continue; const from=sq(r,c); const l=pc.toLowerCase(); if(l==='p'){ const dir=color==='white'?-1:1; const start=color==='white'?6:1; const one=r+dir; if(one>=0&&one<8&&!st.board[one][c]){ pseudo.push({from,to:sq(one,c),piece:pc}); if(r===start&&!st.board[r+2*dir][c]) pseudo.push({from,to:sq(r+2*dir,c),piece:pc,epTarget:sq(one,c)});} for(const dc of[-1,1]){const tr=r+dir,tc=c+dc;if(tr<0||tr>7||tc<0||tc>7) continue; const t=st.board[tr][tc]; if(t&&pColor(t)===opp) pseudo.push({from,to:sq(tr,tc),piece:pc});} if(st.ep){const[er,ec]=pos(st.ep); if(er===r+dir&&Math.abs(ec-c)===1) pseudo.push({from,to:sq(er,ec),piece:pc,enPassant:true});} } else if(l==='n'){ const d=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]; for(const[dr,dc] of d){const tr=r+dr,tc=c+dc; if(tr<0||tr>7||tc<0||tc>7) continue; const t=st.board[tr][tc]; if(!t||pColor(t)===opp) pseudo.push({from,to:sq(tr,tc),piece:pc});} } else if(l==='b'||l==='r'||l==='q'){ const dirs=[]; if(l!=='r') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if(l!=='b') dirs.push([1,0],[-1,0],[0,1],[0,-1]); for(const[dr,dc] of dirs){ let tr=r+dr,tc=c+dc; while(tr>=0&&tr<8&&tc>=0&&tc<8){ const t=st.board[tr][tc]; if(!t) pseudo.push({from,to:sq(tr,tc),piece:pc}); else { if(pColor(t)===opp) pseudo.push({from,to:sq(tr,tc),piece:pc}); break;} tr+=dr; tc+=dc; } } } else if(l==='k'){ for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc) continue; const tr=r+dr,tc=c+dc; if(tr<0||tr>7||tc<0||tc>7) continue; const t=st.board[tr][tc]; if(!t||pColor(t)===opp) pseudo.push({from,to:sq(tr,tc),piece:pc}); } if(!isAttacked(st,kSq,color)){ if(st.castling.includes(color==='white'?'K':'k')) if(!st.board[r][c+1]&&!st.board[r][c+2]&&!isAttacked(st,sq(r,c+1),color)&&!isAttacked(st,sq(r,c+2),color)) pseudo.push({from,to:sq(r,c+2),piece:pc,castle:'king'}); if(st.castling.includes(color==='white'?'Q':'q')) if(!st.board[r][c-1]&&!st.board[r][c-2]&&!st.board[r][c-3]&&!isAttacked(st,sq(r,c-1),color)&&!isAttacked(st,sq(r,c-2),color)) pseudo.push({from,to:sq(r,c-2),piece:pc,castle:'queen'}); } }
 }
 const legal=[]; for(const m of pseudo){ const newSt=applyPseudo(st,m); if(!kingSafe(newSt,color)) continue; if(m.piece==='P'&&m.to[1]==='8'){ ['Q','R','B','N'].forEach(pr=>legal.push({...m,promotion:pr})); continue;} if(m.piece==='p'&&m.to[1]==='1'){ ['q','r','b','n'].forEach(pr=>legal.push({...m,promotion:pr})); continue;} legal.push(m);} state.cache.set(f,legal); return legal; }

function pieceClass(ch){const map={k:'king',q:'queen',r:'rook',b:'bishop',n:'knight',p:'pawn'};return (ch===ch.toUpperCase()?'white ':'black ')+map[ch.toLowerCase()];}

// Verify that the target square matches the movement shape of the piece (ignores blockers)
function isMoveShapeValid(from,to,piece){
    if(!from || !to || !piece) return false;
    const [fr,fc]=pos(from); const [tr,tc]=pos(to);
    const dr = tr-fr, dc = tc-fc;
    const absDr = Math.abs(dr), absDc = Math.abs(dc);
    const p = piece.toLowerCase();
    if(p==='n'){ // knight
        return (absDr===2 && absDc===1) || (absDr===1 && absDc===2);
    }
    if(p==='b'){ // bishop
        return absDr===absDc && absDr>0;
    }
    if(p==='r'){ // rook
        return (dr===0 && dc!==0) || (dc===0 && dr!==0);
    }
    if(p==='q'){ // queen
        return (absDr===absDc && absDr>0) || (dr===0 && dc!==0) || (dc===0 && dr!==0);
    }
    if(p==='k'){ // king: one square any direction (allow castling via two-square horizontal)
        if(Math.max(absDr,absDc)===1) return true;
        if(fr===tr && Math.abs(dc)===2) return true; // allow castle destination shape
        return false;
    }
    if(p==='p'){ // pawn: forward one/two or diagonal capture (direction depends on color)
        const isWhite = piece===piece.toUpperCase();
        const dir = isWhite? -1 : 1;
        // forward one
        if(dc===0 && dr===dir) return true;
        // forward two from starting rank
        const startRank = isWhite?6:1; if(dc===0 && dr===2*dir && fr===startRank) return true;
        // diagonal capture one
        if(Math.abs(dc)===1 && dr===dir) return true;
        return false;
    }
    return false;
}

function renderBoard(){
    const boardEl=document.getElementById('chessboard');
    if(!boardEl) return;
    boardEl.innerHTML='';
    const currentFen = state.fen;
    const st=parseFen(currentFen);
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const div=document.createElement('div');
        div.className='square '+(((r+c)%2===0)?'light':'dark');
        const name=sq(r,c);
        div.dataset.square=name;
        if(highlights.has(name)) div.classList.add('highlight');
        const piece=st.board[r][c];
        if(piece){
            const pc=document.createElement('div');
            pc.className='piece '+pieceClass(piece);
            pc.draggable = state.started && st.active==='white' && pColor(piece)==='white';
            pc.addEventListener('dragstart',e=>{e.dataTransfer.setData('text/plain',name); state.dragFrom=name;});
            pc.addEventListener('dragend',()=>state.dragFrom=null);
            div.appendChild(pc);
        }
    // projection is rendered in-place by renderProjectionForMove to avoid full re-renders
        // Eventi inclusi per annotazioni
    div.addEventListener('click',(e)=>{
        // Click sinistro ovunque: cancella tutte le annotazioni prima di gestire la selezione/mossa
    if(totalArrows() || highlights.size) clearAnnotations();
        onSquareClick(name);
    });
        // Hover projection: when a piece is selected, hovering a legal destination shows a ghost
        // Remove hover-based projection: user wanted projection only when they click to queue a premove
        div.addEventListener('mouseenter', ()=>{
            if(state.selected){
                // if there is an existing projection for the current selection, remove it when user moves over another square
                if(projection && projection.from===state.selected && projection.to!==name) clearProjection();
            }
        });
        div.addEventListener('mouseleave', ()=>{ if(projection && projection.from===state.selected && projection.to===name) clearProjection(); });
        div.addEventListener('dragover',e=>e.preventDefault());
        div.addEventListener('drop',e=>{e.preventDefault(); if(state.dragFrom) tryMove(state.dragFrom,name);});
        div.addEventListener('mousedown',e=>onMouseDownSquare(e,name));
        div.addEventListener('mouseup',e=>onMouseUpSquare(e,name));
        boardEl.appendChild(div);
    }
    // Mosse possibili se impostazione attiva
    if(state.selected){
        if(getPref('showLegalMoves',true)){
            let fenForMoves = currentFen;
            const moves=generateLegalMoves(fenForMoves).filter(m=>m.from===state.selected);
            moves.forEach(m=>{ const t=document.querySelector(`[data-square="${m.to}"]`); if(t){ t.classList.add('possible-move'); if(t.querySelector('.piece')) t.classList.add('occupied'); }});
        }
        const sEl=document.querySelector(`[data-square="${state.selected}"]`); if(sEl) sEl.classList.add('selected');
    }
    // Evidenzia ultima mossa se attivo
    if(getPref('highlightLastMove',true)){
        if(state.lastFrom){ const lf=document.querySelector(`[data-square="${state.lastFrom}"]`); if(lf) lf.classList.add('last-move'); }
        if(state.lastTo){ const lt=document.querySelector(`[data-square="${state.lastTo}"]`); if(lt) lt.classList.add('last-move'); }
    }
    applyHighlightSettings();
    redrawAnnotations();
    renderArrowRemoveMarker();
    updateGameStatus();
    // Rehydrate premove DOM classes and persistent premove ghosts after full re-render
    if(premoves && premoves.length){
        premoves.forEach(p=>{
            try{
                const fEl = document.querySelector(`[data-square="${p.from}"]`);
                if(fEl) fEl.classList.add('premove-origin');
                const tEl = document.querySelector(`[data-square="${p.to}"]`);
                if(tEl) tEl.classList.add('premove-target');
                addPremoveProjection(p);
            }catch(e){/* ignore */}
        });
    }
    // cleanup any orphan premove classes after rehydration
    try{ syncPremoveDom(); }catch(e){}
}

// === Funzioni Annotazioni (portate da play.html con adattamenti) ===
function clearAnnotations(){
    // Remove arrow layers and any user-created highlights, but keep premove highlights
    if(!totalArrows() && highlights.size === 0) return;
    // clear arrows
    arrowLayers.A.length = 0;
    arrowLayers.B.length = 0;
    // remove only non-premove highlights: premoveRefCount tracks premove squares
    if(premoveRefCount && premoveRefCount.size > 0){
        for(const sq of Array.from(highlights)){
            if(!premoveRefCount.has(sq)) highlights.delete(sq);
        }
    } else {
        // no premoves active: safe to clear all highlights
        highlights.clear();
    }
    arrowRemoveStart = null;
    redrawAnnotations();
    updateHighlightDom();
    renderArrowRemoveMarker();
}
function clearActiveArrows(){ const arr=activeArrows(); if(arr.length){ arr.length=0; redrawAnnotations(); }}
function clearAllArrows(){ clearAnnotations(); }
function toggleHighlight(s){
    // Do not allow toggling off a premove-highlighted square via right-click if it's part of any premove
    if(highlights.has(s)){
        if(premoveRefCount && premoveRefCount.has(s)) return; // keep it
        highlights.delete(s);
    } else {
        highlights.add(s);
    }
    updateHighlightDom();
}
function updateHighlightDom(){ document.querySelectorAll('.square.highlight').forEach(el=>{const n=el.dataset.square; if(!highlights.has(n)) el.classList.remove('highlight');}); highlights.forEach(n=>{const el=document.querySelector(`[data-square="${n}"]`); if(el) el.classList.add('highlight');}); applyHighlightSettings(); }
function applyHighlightSettings(){
    let colorHex=getPref('highlightColor','#8b4d8b');
    let op=(getPref('highlightOpacity',80))/100;
    if(!colorHex) colorHex='#8b4d8b';
    const r=parseInt(colorHex.slice(1,3),16),g=parseInt(colorHex.slice(3,5),16),b=parseInt(colorHex.slice(5,7),16);
    let stEl=document.getElementById('highlight-dynamic-style');
    if(!stEl){ stEl=document.createElement('style'); stEl.id='highlight-dynamic-style'; document.head.appendChild(stEl); }
        stEl.textContent=`
        .square.highlight{position:relative;background:rgba(${r},${g},${b},${op*0.3});}
        .square.highlight::before{content:'';position:absolute;inset:0;pointer-events:none;z-index:800;
                background: radial-gradient(circle at center, transparent 0 80%, rgba(${r},${g},${b},${op}) 80% 100%);
        }
        `;
}
function onMouseDownSquare(e,name){
    // If a premove exists, right-click should cancel premoves rather than start arrow drag/selection
    if(e.button===2){
        if(premoves && premoves.length>0){
            // consume the mousedown; actual cancellation handled on mouseup
            arrowDragStart = null; return;
        }
        arrowDragStart = name;
    } else if(e.button===0) {
        removeArrowDragStart = name;
    }
}
function onMouseUpSquare(e,name){
    // Right button: if a premove exists, cancel it instead of toggling highlight/arrow
    if(e.button===2){
        if(premoves && premoves.length>0){
            try{ clearAllPremoves(); renderBoard(); redrawAnnotations(); }catch(err){}
            arrowDragStart=null;
            return;
        }
        if(arrowDragStart){
            const from=arrowDragStart,to=name;
            if(from!==to) toggleArrow(from,to); else toggleHighlight(from);
            arrowDragStart=null;
            if(state.selected){ state.selected=null; }
            redrawAnnotations();
            return;
        }
    }
    
    // Left button: rimozione frecce (drag) o highlight (click stesso quadrato)
    if(e.button===0 && removeArrowDragStart){
        const from=removeArrowDragStart; const to=name;
        if(from===to){
            // prevent removing premove highlight by left-click on a premove square
            if(highlights.has(from)){
                if(!(premoveRefCount && premoveRefCount.has(from))){ highlights.delete(from); updateHighlightDom(); }
            }
        } else {
            if(removeArrowBetween(from,to)) redrawAnnotations();
        }
        removeArrowDragStart=null;
    }
}
function toggleArrow(from,to){ const arr=activeArrows(); const idx=arr.findIndex(a=>a.from===from&&a.to===to); if(idx>=0) arr.splice(idx,1); else arr.push({from,to}); }
function removeArrowBetween(a,b){ // cerca su entrambi i layer
    for(const key of Object.keys(arrowLayers)){
        const layer=arrowLayers[key];
        const idx=layer.findIndex(ar=> (ar.from===a&&ar.to===b)||(ar.from===b&&ar.to===a));
        if(idx>=0){ layer.splice(idx,1); return true; }
    }
    return false;
}
// layer switching UI removed; keeping currentArrowLayer constant
function renderArrowRemoveMarker(){ document.querySelectorAll('.square.arrow-remove-start').forEach(el=>el.classList.remove('arrow-remove-start')); if(arrowRemoveStart){ const el=document.querySelector(`[data-square="${arrowRemoveStart}"]`); if(el) el.classList.add('arrow-remove-start'); } }
function redrawAnnotations(){ const canvas=document.getElementById('annotations-canvas'); if(!canvas) return; const board=document.getElementById('chessboard'); const rect=board.getBoundingClientRect(); canvas.width=rect.width; canvas.height=rect.height; const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); const squareSize=canvas.width/8; const scaleFactor=squareSize/70; // Layer 1 (A)
    arrowLayers.A.forEach(a=>drawArrow(ctx,a.from,a.to,'A',canvas,scaleFactor));
    // Layer 2 (B)
    arrowLayers.B.forEach(a=>drawArrow(ctx,a.from,a.to,'B',canvas,scaleFactor)); }
function drawArrow(ctx,from,to,layerKey,canvas,scale){ const [fr,fc]=pos(from); const [tr,tc]=pos(to); const ss=canvas.width/8; const fromX=(fc+0.5)*ss, fromY=(fr+0.5)*ss, toX=(tc+0.5)*ss, toY=(tr+0.5)*ss; let baseColor=getPref('arrowColor','#8b4d8b'); const altColor='#ffce54'; const arrowColor= layerKey==='A'? baseColor : altColor; const opacity=(getPref('arrowOpacity',80))/100; const baseThickness=(getPref('arrowThickness',12))*scale; const thickness = layerKey==='A'? baseThickness : Math.max(4, baseThickness*0.7); ctx.globalAlpha = layerKey==='A'? opacity : Math.min(1, opacity*0.9); ctx.strokeStyle=arrowColor; ctx.fillStyle=arrowColor; ctx.lineWidth=thickness; ctx.lineCap='round'; const angle=Math.atan2(toY-fromY,toX-fromX); const arrowLen=(layerKey==='A'?30:26)*scale; const shorten=arrowLen*0.7; const adjX=toX-shorten*Math.cos(angle); const adjY=toY-shorten*Math.sin(angle); ctx.beginPath(); if(layerKey==='B'){ const midX=(fromX+adjX)/2 + 12*scale*Math.sin(angle); const midY=(fromY+adjY)/2 - 12*scale*Math.cos(angle); ctx.moveTo(fromX,fromY); ctx.quadraticCurveTo(midX,midY,adjX,adjY); ctx.setLineDash([Math.max(6,12*scale),Math.max(4,8*scale)]);} else { ctx.moveTo(fromX,fromY); ctx.lineTo(adjX,adjY); ctx.setLineDash([]);} ctx.stroke(); ctx.setLineDash([]); const arrowAngle=Math.PI/4.5; ctx.beginPath(); ctx.moveTo(toX,toY); ctx.lineTo(toX-arrowLen*Math.cos(angle-arrowAngle), toY-arrowLen*Math.sin(angle-arrowAngle)); ctx.lineTo(toX-arrowLen*Math.cos(angle+arrowAngle), toY-arrowLen*Math.sin(angle+arrowAngle)); ctx.closePath(); ctx.fill(); ctx.globalAlpha=1; }
// Blocca menu contestuale sul board per usare tasto destro
document.addEventListener('contextmenu',e=>{ if(e.target && e.target.closest && e.target.closest('#chessboard')) e.preventDefault(); });
window.addEventListener('resize',()=>redrawAnnotations());
// removed updateArrowLayerUI call (UI deleted)

function onSquareClick(name){
    if(!state.started || state.gameOver) return;
    // Use canonical state FEN for selection (no projection)
    const displayedFen = state.fen;
    if(state.selected){
        if(state.selected===name){ state.selected=null; renderBoard(); return; }
        if(!tryMove(state.selected,name)){
            // maybe select new piece if ours (based on displayed position)
            const st=parseFen(displayedFen);
            const [r,c]=pos(name);
            const pc=st.board[r][c];
            if(pc && (pColor(pc)===st.active || (isBotThinking && getPref('enablePremoves', true) && pColor(pc)==='white'))){ state.selected=name; renderBoard(); }
        }
    } else {
        const st=parseFen(displayedFen);
        const [r,c]=pos(name);
        const pc=st.board[r][c];
        if(pc && (pColor(pc)===st.active || (isBotThinking && getPref('enablePremoves', true) && pColor(pc)==='white'))){ state.selected=name; renderBoard(); }
    }
}
function tryMove(from,to){ 
    console.debug('[tryMove] from, to, isBotThinking:', from, to, isBotThinking);
    let fenForMoves = state.fen;
    if(isBotThinking && getPref('enablePremoves', true)){
        const parts = state.fen.split(' ');
        parts[1] = 'w'; // set active to white for premoves
        fenForMoves = parts.join(' ');
    }
    const moves=generateLegalMoves(fenForMoves);
    const mv=moves.find(m=>m.from===from&&m.to===to);
    // If no legal move now but bot is thinking and premoves enabled, allow deferred premove
    if(!mv){
        if(isBotThinking && getPref('enablePremoves', true)){
            // create a deferred premove: store from,to and current piece (if any)
            const stNow = parseFen(fenForMoves);
            const [fr,fc]=pos(from);
            const piece = stNow.board[fr][fc];
            if(!piece){ flashInvalid(to); return false; }
            // ensure the target matches the piece movement shape (ignores blockers)
            if(!isMoveShapeValid(from,to,piece)){ flashInvalid(to); return false; }
            const prem = { from, to, piece };
            prem._deferred = true;
            // promotions will be handled at execution time
            prem._id = String(Date.now()) + '-' + Math.floor(Math.random()*100000);
            try{ clearAllPremoves(); }catch(e){}
            premoves.push(prem);
            state.selected = null;
            renderBoard();
            addPremoveHighlights(prem);
            try{ addPremoveProjection(prem); }catch(e){}
            return true;
        }
        flashInvalid(to);
        return false;
    }
    if(mv.promotion && (mv.piece==='P' || mv.piece==='p')) { showPromotion(from,to,mv); return true; }
    if(isBotThinking){
        if(getPref('enablePremoves', true)){
            // Single premove mode for now: clear existing premoves and push the new one
            try{ clearAllPremoves(); }catch(e){}
            // push new premove to queue. Do not show projection or highlight
            // If the move is a promotion, store the promotion=null in the premove and prompt when executing
            const prem = {...mv};
            if(prem.promotion){ prem._awaitPromotion = true; prem.promotion = null; }
            // unique id for this premove (used to keep its ghost DOM element)
            prem._id = String(Date.now()) + '-' + Math.floor(Math.random()*100000);
            // push to queue
            premoves.push(prem);
            // clear logical selection and render board; ensure visual selection/possible-move markers are removed
            state.selected = null;
            // render board first then adjust highlights so DOM nodes exist
            renderBoard();
            // Defensive cleanup: remove any lingering .selected or .possible-move classes
            document.querySelectorAll('.square.selected').forEach(el=>el.classList.remove('selected'));
            document.querySelectorAll('.square.possible-move').forEach(el=>{ el.classList.remove('possible-move','occupied'); });
            // clear any ephemeral hover projection
            try{ clearProjection(); }catch(e){}
            // set premove path highlights (uses same highlight style as right-click)
            const path = computePremovePath(prem.from, prem.to);
            addPremoveHighlights(prem);
            // show a persistent projection ghost for this premove
            try{ addPremoveProjection(prem); }catch(e){/* ignore */}
            return true;
        } else {
            // Non permettere mosse mentre bot pensa se premoves non abilitato
            flashInvalid(to);
            return false;
        }
    } else {
        applyMove(mv); return true;
    }
}
function flashInvalid(s){ const el=document.querySelector(`[data-square="${s}"]`); if(!el) return; el.classList.add('invalid'); setTimeout(()=>el.classList.remove('invalid'),350); }
function applyMove(m){
    const st=parseFen(state.fen);
    const ns=applyPseudo(st,m);
    state.lastFrom=m.from; state.lastTo=m.to;
    state.fen=composeFen(ns);
    // Play move/capture sound (respect user settings)
    try{
        // detect capture: target square had a piece before move
        const [tr,tc] = pos(m.to);
        const captured = !!st.board[tr][tc];
        playMoveSound(captured ? 'capture' : 'move');
    }catch(e){/* ignore audio errors */}
    // Preserve selection if user had selected a square during opponent's turn and
    // the piece is still present after this move and belongs to the side to move
    const prevSelected = state.selected;
    state.cache.clear();
    checkGameEnd();
    if(prevSelected){
        const stNew = parseFen(state.fen);
        const [sr,sc] = pos(prevSelected);
        const p = stNew.board[sr][sc];
        if(!(p && pColor(p)===stNew.active)){
            state.selected = null;
        }
        // otherwise keep the previous selection so legal moves still show
    } else {
        state.selected = null;
    }
    renderBoard();
    if(!state.gameOver && parseFen(state.fen).active==='black') scheduleBotMove();
}

function checkGameEnd(){ const moves=generateLegalMoves(state.fen); const st=parseFen(state.fen); const color=st.active; let king=null; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=st.board[r][c]; if(p&&p.toLowerCase()==='k'&&pColor(p)===color) king=sq(r,c);} const inCheck=isAttacked(st,king,color); if(moves.length===0){ state.gameOver=true; if(inCheck){ state.winner=other(color); showGameOver(`${state.winner==='white'?'Bianco':'Nero'} vince!`,'Scacco Matto'); } else { showGameOver('Patta','Stallo'); } }}

function updateGameStatus(){ const el=document.getElementById('game-status'); if(state.gameOver){ el.textContent= state.winner ? (state.winner==='white'?'Bianco vince':'Nero vince') : 'Patta'; return;} if(!state.started){ el.textContent='Seleziona un bot e avvia'; return;} const active=parseFen(state.fen).active; el.textContent='Turno del '+(active==='white'?'Bianco':'Nero'); }

// PROMOZIONE
function showPromotion(from,to,proto){ const overlay=document.getElementById('promotionOverlay'); const grid=document.getElementById('promotionChoices'); grid.innerHTML=''; const white=parseFen(state.fen).active==='white'; const list=white?['Q','R','B','N']:['q','r','b','n']; list.forEach(p=>{ const div=document.createElement('div'); div.className='promo-choice'; div.textContent=p.toUpperCase(); div.onclick=()=>{ overlay.style.display='none'; applyMove({...proto,promotion:p}); }; grid.appendChild(div); }); overlay.style.display='flex'; }
function hidePromotion(){ document.getElementById('promotionOverlay').style.display='none'; }

// GAME OVER
function showGameOver(title,detail){ const ov=document.getElementById('gameOverOverlay'); document.getElementById('gameOverTitle').textContent=title; document.getElementById('gameOverDetail').textContent=detail; ov.style.display='flex'; }
function hideGameOver(){ document.getElementById('gameOverOverlay').style.display='none'; }

// BOT
function selectBot(card,type){ document.querySelectorAll('.bot-card').forEach(c=>c.classList.remove('selected')); card.classList.add('selected'); state.botType=type; document.getElementById('startBtn').disabled=false; const lvlBox=document.getElementById('stockfish-level-box'); if(type==='stockfish') lvlBox.classList.add('visible'); else lvlBox.classList.remove('visible'); }
function updateStockfishLevel(val){ state.botLevel=parseInt(val); const span=document.getElementById('stockfishLevelVal'); if(span) span.textContent=val; }
function startGame(){ if(!state.botType) return; state.started=true; state.fen=START_FEN; state.gameOver=false; state.winner=null; state.lastFrom=null; state.lastTo=null; state.cache.clear(); clearAllPremoves(); renderBoard(); updateGameStatus(); document.getElementById('startBtn').disabled=true; }
function scheduleBotMove(){ if(state.botType) setTimeout(makeBotMove, 150); }
function makeBotMove(){ 
    isBotThinking = true;
    const st=parseFen(state.fen); 
    if(st.active!=='black' || state.gameOver) { isBotThinking = false; return; } 
    const moves=generateLegalMoves(state.fen); 
    if(moves.length===0) { checkGameEnd(); isBotThinking = false; return; }
    if(state.botType==='random'){ 
        const mv=moves[Math.floor(Math.random()*moves.length)]; 
        applyMove(mv); 
    console.debug('[makeBotMove] random applied', { stateFen: state.fen, premoves: premoves.slice() });
    isBotThinking = false;
    applyNextPremove();
        return; 
    }
    if(state.botType==='stockfish'){ 
        fetch('/api/game/bot-move',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({fen:state.fen,level:state.botLevel})})
            .then(r=>r.ok?r.json():Promise.reject())
            .then(d=>{ 
                if(!d||!d.move){ // fallback
                    const mv=moves[Math.floor(Math.random()*moves.length)]; 
                    applyMove(mv); 
                } else {
                    const uci=d.move.trim(); 
                    const from=uci.slice(0,2), to=uci.slice(2,4); 
                    const promo=uci.length>4?uci[4]:null; 
                    const mv=moves.find(m=>m.from===from&&m.to===to&&(!m.promotion || m.promotion.toLowerCase()===promo)); 
                    if(mv) applyMove(mv); 
                    else { const fb=moves[Math.floor(Math.random()*moves.length)]; applyMove(fb);}
                }
                console.debug('[makeBotMove] stockfish then applied', { stateFen: state.fen, premoves: premoves.slice(), resp: d });
                isBotThinking = false;
                applyNextPremove();
            })
            .catch(()=>{ 
                const mv=moves[Math.floor(Math.random()*moves.length)]; 
                applyMove(mv); 
                console.debug('[makeBotMove] stockfish catch applied', { stateFen: state.fen, premoves: premoves.slice() });
                isBotThinking = false;
                applyNextPremove();
            }); 
    }
}

function applyNextPremove(){
    if(!getPref('enablePremoves', true) || premoves.length === 0) return;
    console.debug('[applyNextPremove] start', { stateFen: state.fen, premoves: premoves.slice() });
    const mv = premoves.shift();
    // If this is a deferred premove (stored when not legal), resolve it now
    if(mv._deferred){
        const currentMoves = generateLegalMoves(state.fen);
        // Try to find a legal move that matches from->to (may include promotion variants)
        const resolved = currentMoves.find(m => m.from === mv.from && m.to === mv.to);
        if(!resolved){
            // cannot resolve now: remove visuals and continue
            try{ removePremoveHighlights(mv); }catch(e){}
            applyNextPremove();
            return;
        }
        // copy resolved move details into mv so the rest of the flow can apply it
        Object.assign(mv, resolved);
    } else {
        // Check if the move is still valid in the current position
        const currentMoves = generateLegalMoves(state.fen);
        const isValid = currentMoves.some(m => m.from === mv.from && m.to === mv.to && (!mv.promotion || m.promotion === mv.promotion));
        if (!isValid) {
            // Skip invalid premove: remove its highlights/projection then continue
            try{ removePremoveHighlights(mv); }catch(e){}
            applyNextPremove();
            return;
        }
    }
    // Check if the piece is still there
    const st = parseFen(state.fen);
    const [fr, fc] = pos(mv.from);
    const piece = st.board[fr][fc];
    if (!piece) {
        // Skip if piece is not there: clean up highlights/projection then continue
        try{ removePremoveHighlights(mv); }catch(e){}
        applyNextPremove();
        return;
    }
    // If this premove awaits a promotion, prompt now
    if(mv._awaitPromotion){
        // Show promotion overlay and when chosen, apply the stored move with chosen promotion
        const overlay=document.getElementById('promotionOverlay');
        const grid=document.getElementById('promotionChoices');
        grid.innerHTML='';
        const white=parseFen(state.fen).active==='white';
        const list=white?['Q','R','B','N']:['q','r','b','n'];
    list.forEach(p=>{ const div=document.createElement('div'); div.className='promo-choice'; div.textContent=p.toUpperCase(); div.onclick=()=>{ overlay.style.display='none';
        try{ removePremoveHighlights(mv); }catch(e){}
        applyMove({...mv,promotion:p}); // after applying, continue with next premove
        const st2 = parseFen(state.fen); if(st2.active === 'white' && !state.gameOver){ setTimeout(applyNextPremove, 100); } }; grid.appendChild(div); });
        overlay.style.display='flex';
        return;
    }
    // Remove premove path highlights for the premove we're about to apply
    removePremoveHighlights(mv);

    // Apply move normally
    applyMove(mv);
    console.debug('[applyNextPremove] applied', { stateFen: state.fen, premoves: premoves.slice() });
    // If there is another premove queued, highlight its path (latest)
    if(premoves.length>0){
        const next=premoves[0];
        addPremoveHighlights(next);
    }
    // If queue is now empty, ensure all premove state is cleared
    if(!premoves || premoves.length===0){ try{ clearAllPremoves(); }catch(e){} }
    const st2 = parseFen(state.fen);
    if(st2.active === 'white' && !state.gameOver){
        setTimeout(applyNextPremove, 100);
    }
}

// Remove all premoves, highlights and persistent projections (used on reset or disabling premoves)
function clearAllPremoves(){
    try{
        if(Array.isArray(premoves)){
            premoves.forEach(p=>{ try{ removePremoveHighlights(p); }catch(e){} try{ removePremoveProjection(p); }catch(e){} });
        }
    }catch(e){}
    // remove any remaining projected pieces with premove id
    document.querySelectorAll('.projected-piece[data-premove-id]').forEach(n=>n.remove());
    premoves = [];
    premoveRefCount.clear();
    updateHighlightDom();
    // Sweep DOM to remove any premove-origin/target classes that are orphaned
    try{ syncPremoveDom(); }catch(e){}
}

// Ensure DOM premove classes match premoveRefCount (remove orphan classes)
function syncPremoveDom(){
    // If there are no premoves, clear all premove ref counts and remove any leftover DOM markers
    if(!premoves || premoves.length === 0){
        premoveRefCount.clear();
        document.querySelectorAll('.square.premove-origin, .square.premove-target').forEach(el=>el.classList.remove('premove-origin','premove-target'));
        document.querySelectorAll('.projected-piece[data-premove-id]').forEach(n=>n.remove());
        return;
    }
    // For every element with premove-origin/target, remove class if no ref exists
    document.querySelectorAll('.square.premove-origin').forEach(el=>{ const s = el.dataset.square; if(!premoveRefCount.has(s)) el.classList.remove('premove-origin'); });
    document.querySelectorAll('.square.premove-target').forEach(el=>{ const s = el.dataset.square; if(!premoveRefCount.has(s)) el.classList.remove('premove-target'); });
    // Also remove any projected-piece elements whose premove id isn't present in premoves
    const ids = new Set((premoves||[]).map(p=>p._id));
    document.querySelectorAll('.projected-piece[data-premove-id]').forEach(n=>{ if(!ids.has(n.dataset.premoveId)) n.remove(); });
}

function resetGame(){ state.fen=START_FEN; state.selected=null; state.lastFrom=null; state.lastTo=null; state.cache.clear(); state.gameOver=false; state.winner=null; state.started=false; clearAllPremoves(); document.getElementById('startBtn').disabled = !state.botType; hidePromotion(); hideGameOver(); renderBoard(); updateGameStatus(); }

// TIME CONTROL (semplificato placeholder)
function changeTimeControl(val){ const box=document.getElementById('timerBox'); if(val==='unlimited'){ box.classList.remove('active'); } else { box.classList.add('active'); document.getElementById('whiteTime').textContent='--:--'; document.getElementById('blackTime').textContent='--:--'; } }

// SETTINGS OPEN/CLOSE (delegati a settings.js se presente)
function openSettings(){ const ov=document.getElementById('settingsOverlay'); if(ov) ov.style.display='block'; }
function closeSettings(){ const ov=document.getElementById('settingsOverlay'); if(ov) ov.style.display='none'; }
function openAdvancedSettings(){ openSettings(); }

document.addEventListener('DOMContentLoaded',()=>{ renderBoard(); updateGameStatus(); updateStockfishLevel(state.botLevel); 

    // Debug: log DOMContentLoaded and attach a capture listener to the premove toggle
    try{ console.log('[bot.html] DOMContentLoaded fired'); }catch(e){}
    try{
        const dbgP = document.getElementById('enablePremoves');
        console.log('[bot.html] premove toggle element (debug)', dbgP);
        if(dbgP){
            dbgP.addEventListener('click', function(ev){
                console.log('[bot.html][debug] enablePremoves clicked (capture listener)', {classList: dbgP.className, time: Date.now()});
                // visually toggle for debug
                dbgP.classList.toggle('active');
                try{ safeSetSetting('enablePremoves', dbgP.classList.contains('active')); }catch(e){ console.warn('[bot.html][debug] safeSetSetting not available', e); }
            }, true); // capture to intercept even if some overlay stops propagation
        }
    }catch(e){ console.warn('[bot.html][debug] attach premove debug listener failed', e); }

    // Gestione toggle Mosse Legali
    const legalToggle = document.getElementById('showLegalMoves');
    if(legalToggle){
        function syncLegal(){
            const lm = !!safeGetSetting('showLegalMoves', true);
            legalToggle.classList.toggle('active', lm);
        }
        // If settings.js already setups toggles, avoid adding a duplicate listener here
        if(typeof setupToggle === 'function'){
            // let the central settings system manage clicks; just sync UI
            setTimeout(syncLegal, 40);
        } else {
            legalToggle.addEventListener('click', ()=>{
                const current = !!safeGetSetting('showLegalMoves', true);
                const newVal = !current;
                safeSetSetting('showLegalMoves', newVal);
                if(!newVal){
                    document.querySelectorAll('.square.possible-move').forEach(e=>e.classList.remove('possible-move','occupied'));
                } else {
                    renderBoard();
                }
                syncLegal();
            });
            // ensure UI reflects stored value quickly
            setTimeout(syncLegal, 40);
        }
    }

    // Gestione toggle Premoves
    const premoveToggle = document.getElementById('enablePremoves');
    if(premoveToggle){
        function syncPremoves(){
            const pr = !!safeGetSetting('enablePremoves', true);
            premoveToggle.classList.toggle('active', pr);
        }
        if(typeof setupToggle === 'function'){
            // central settings handles clicks
            setTimeout(syncPremoves, 40);
        } else {
            premoveToggle.addEventListener('click', ()=>{
                const current = !!safeGetSetting('enablePremoves', true);
                const newVal = !current;
                safeSetSetting('enablePremoves', newVal);
                if(!newVal){
                    // premove highlights disabled: clear any queued premoves and visual markers
                    try{ clearAllPremoves(); renderBoard(); }catch(e){}
                }
                syncPremoves();
            });
            setTimeout(syncPremoves, 40);
        }
    }

    // Gestione toggle Ultima Mossa
    const lastMoveToggle = document.getElementById('highlightLastMove');
    if(lastMoveToggle){
        function syncLastMove(){
            const hl = !!safeGetSetting('highlightLastMove', true);
            lastMoveToggle.classList.toggle('active', hl);
        }
        if(typeof setupToggle === 'function'){
            // central settings handles clicks
            setTimeout(syncLastMove, 40);
        } else {
            lastMoveToggle.addEventListener('click', ()=>{
                const current = !!safeGetSetting('highlightLastMove', true);
                const newVal = !current;
                safeSetSetting('highlightLastMove', newVal);
                renderBoard(); // Rigenera la board per aggiornare highlights
                syncLastMove();
            });
            setTimeout(syncLastMove, 40);
        }
    }
});
</script>
</body>
</html>